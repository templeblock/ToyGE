<?xml version="1.0" encoding="utf-8"?>

<effect>
  

  <shader>    
    <![CDATA[

int2 NextCell(float3 pos_T, float3 tracingDir_T, int2 texSize, int2 cellSize)
{
  float2 pos_C = pos_T.xy * (float2)texSize / (float2)cellSize;
  
  int2 cellIndex = (int2)pos_C;
  
  if( tracingDir_T.x > 0.0 && frac(pos_C.x) > 0.99 )
    ++cellIndex.x;
  else if( tracingDir_T.x < 0.0 && frac(pos_C.x) < 0.01)
    --cellIndex.x;
    
  if( tracingDir_T.y > 0.0 && frac(pos_C.y) > 0.99 )
    ++cellIndex.y;
  else if( tracingDir_T.y < 0.0 && frac(pos_C.y) < 0.01)
    --cellIndex.y;
    
  return cellIndex;
}

float GetCellBoundStepDist(float3 pos_T, float3 tracingDir_T, int2 texSize, int2 cellSize, int2 cellIndex)
{
  float2 pos_C = pos_T.xy * (float2)texSize / (float2)cellSize;
  
  float d_x;
  if( tracingDir_T.x > 0.0f )
    d_x = ( (float)(cellIndex.x + 1) - pos_C.x ) / tracingDir_T.x * cellSize.x;
  else if(tracingDir_T.x < 0.0f)
    d_x = ( (float)(cellIndex.x)     - pos_C.x ) / tracingDir_T.x * cellSize.x;
  else
    d_x = FLT_MAX;
      
  float d_y;
  if( tracingDir_T.y > 0.0f )
    d_y = ( (float)(cellIndex.y + 1) - pos_C.y ) / tracingDir_T.y * cellSize.y;
  else if(tracingDir_T.y < 0.0f)
    d_y = ( (float)(cellIndex.y)     - pos_C.y ) / tracingDir_T.y * cellSize.y;
  else
    d_y = FLT_MAX;
  
  return min(d_x, d_y);
}

float GetZStepDist(float3 pos_T, float3 tracingDir_T, Texture2D hizTex, int level, int2 cellSize, int2 cellIndex)
{
  float texZ = hizTex.Load( int3(cellIndex, level) ).x;
  
  float d;
  if( abs(tracingDir_T.z) > 0.001 )
  {
    d = (texZ - pos_T.z) / tracingDir_T.z;
  }
  else
  {
    d = FLT_MAX;
  }
  return d;
}

#define MAX_ITERATION 20

float3 HiZTracing(float3 pos_T, float3 tracingDir_T, Texture2D hizTex, out bool bHit)
{
  int2 texSize;
  int numMips;
  hizTex.GetDimensions(0, texSize.x, texSize.y, numMips);

  int level = 0;
  int2 cellSize = 1;
  
  float3 posTraced_T = pos_T;
  
  int2 cellIndex_a = NextCell(posTraced_T, tracingDir_T, texSize, cellSize);
  float d_a = GetCellBoundStepDist(posTraced_T, tracingDir_T, texSize, cellSize, cellIndex_a);
  if( d_a == FLT_MAX )
  {
    bHit = false;
    //return pos_T;
  }
  else
  {
  posTraced_T += d_a * tracingDir_T;
  
  bHit = true;
  int itr = 0;
  [loop] while(level >= 0 && itr < MAX_ITERATION)
  {
    int2 cellIndex = NextCell(posTraced_T, tracingDir_T, texSize, cellSize);
    float d_c = GetCellBoundStepDist(posTraced_T, tracingDir_T, texSize, cellSize, cellIndex);
    float d_z = GetZStepDist(posTraced_T, tracingDir_T, hizTex, level, cellSize, cellIndex);
    
    float d = min(d_c, d_z);
    if( d == FLT_MAX )
    {
      bHit = false;
      break;
    }
    if( d < -0.01f )
    {
      bHit = false;
      break;
    }
    
    posTraced_T += tracingDir_T * d;
    if( d == d_c )
      level = min(numMips - 1, level + 1);
    else
      --level;
      
    cellSize = min(texSize, 1 << max(0, level));
      
    ++itr;
  }
  }
  
  return posTraced_T;
}

float3 TransToTracingSpace(float3 posV, float4x4 proj, float2 camNearFar)
{
  float4 posH = mul(float4(posV, 1.0f), proj);
  posH /= posH.w;
  float2 xy = posH.xy * float2(0.5f, -0.5f) + 0.5f;
  float z = (posV.z - camNearFar.x) / (camNearFar.y - camNearFar.x);
  return float3(xy, z);
}
    
    ]]>    
  </shader>

</effect>
