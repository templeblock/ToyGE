<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="Defines.xml"/>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>
  <!--<include name="BlurConfig.xml"/>-->
  <include name="Util.xml"/>



  <variable type="cbuffer" name="cb_coc">
    <variable type="float" name="focalLength"/>
    <variable type="float" name="focalDistance"/>
    <variable type="float" name="aperture"/>
    <variable type="float" name="pixelsPerMM"/>
    <variable type="float2" name="camNearFar"/>
    <variable type="float2" name="_pad_coc"/>
  </variable>
  
  <variable type="Texture2D" name="linearDepthTex"/>
  
  <shader>
    <![CDATA[
    
float ComputeCoCPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float f = focalLength; // in mm
  float p = linearDepthTex.SampleLevel(samplerPoint, vsOut.tex, 0).x;
  p = p * (camNearFar.y - camNearFar.x) + camNearFar.x;
  float o = focalDistance;
  float d = aperture; // in mm
  
  p *= 1000.0f;
  
  float c = d * f * (o - p) / (p * (o - f));
  
  return c * pixelsPerMM;
}
    
    ]]>
  </shader>

  <variable type='DepthStencilState' name='objStencilDSS'>
    <state name='depthEnable' value='false'/>
    <state name='depthWriteMask' value='ZERO'/>
    <state name='stencilEnable' value='true'/>
    <state name='frontFace'>
      <state name='stencilFunc' value='EQUAL'/>
    </state>
    <state name='backFace'>
      <state name='stencilFunc' value='EQUAL'/>
    </state>
    <state name='stencilRef' value='1'/>
  </variable>

  <technique name="ComputeCoC">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ComputeCoCPS"/>
    </pass>
  </technique>


  <variable type="cbuffer" name="cb_layer">
    <variable type="float" name="maxBlur"/>
    <variable type="float3" name="_pad_layer"/>
  </variable>

  <variable type="Texture2D" name="cocTex"/>
  <variable type="Texture2D" name="sceneTex"/>

  <shader>
    <![CDATA[
    
void SplitLayersPS(
  PostProcessVSOut vsOut,
  out float4 nearLayer : SV_TARGET0,
  out float4 farLayer  : SV_TARGET1)
{
  nearLayer = 0.0f;
  farLayer  = 0.0f;
  
  float coc = cocTex.SampleLevel(samplerPoint, vsOut.tex, 0).x;
  //float blurSize = abs(coc) * maxBlur;
  if(abs(coc) > 0.5f)
  {
    float4 sceneColor = sceneTex.SampleLevel(samplerLinear, vsOut.tex, 0);
    if(sign(coc) > 0.0f)
    {
      nearLayer.xyz = sceneColor.xyz;
      nearLayer.w = 1.0f;
    }
    else
    {
      farLayer.xyz  = sceneColor.xyz;
      farLayer.w = 1.0f;
    }
  }
  
}
    
    ]]>
  </shader>

  <technique name="SplitLayers">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="SplitLayersPS"/>
    </pass>
  </technique>


  <variable type="cbuffer" name="cb_blur">
    <variable type="float2" name="texelSize"/>
  </variable>

  <variable type="Texture2D" name="downSampleInTex"/>

  <shader>
    <![CDATA[
    
float4 DownSamplePS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 tex = vsOut.pos.xy * texelSize;
  return downSampleInTex.SampleLevel(samplerLinearClamp, tex, 0);
}

    ]]>
  </shader>

  <technique name="DownSample">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="DownSamplePS"/>
    </pass>
  </technique>

  
  <variable type="Texture2D" name="blurInputTex"/>

  <shader>
    <![CDATA[
    
#define NUM_DISK_SAMPLES 16
    
float2 GetDiskOffset(int index)
{
  static const float2 DiscKernel[NUM_DISK_SAMPLES] = {
    float2(0.2069841f, 0.2245269f),
    float2(0.525808f, -0.2310817f),
    float2(0.1383943f, 0.9056122f),
    float2(0.6633009f, 0.5129843f),
    float2(-0.4002792f, 0.3727058f),
    float2(0.07912822f, -0.6512921f),
    float2(-0.7726067f, -0.5151217f),
    float2(-0.3843193f, -0.1494132f),
    float2(-0.9107782f, 0.2500633f),
    float2(0.6940153f, -0.7098927f),
    float2(-0.1964669f, -0.379389f),
    float2(-0.4769286f, 0.1840863f),
    float2(-0.247328f, -0.8798459f),
    float2(0.4206541f, -0.714772f),
    float2(0.5829348f, -0.09794202f),
    float2(0.3691838f, 0.4140642f)
  };
  
  return DiscKernel[index];
}

float4 UnfocusedDiskBlurPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 t_o = vsOut.pos.xy * texelSize;
  
  float coc_o = cocTex.SampleLevel(samplerPoint, t_o, 0).x;

  float4 color = 0.0f;
  float weightAll = 0.0f;
  
  float4 color_o = blurInputTex.SampleLevel(samplerPointClamp, t_o, 0);
  color += color_o;
  weightAll += 1.0f;
  
  float2 offset = min(abs(coc_o), maxBlur) * 0.5f * texelSize;
  
  for(int i = 0; i < NUM_DISK_SAMPLES; ++i)
  {
    float2 diskOffset = GetDiskOffset(i);
    float2 t_i = t_o + diskOffset * offset;
    
    float coc_i = cocTex.SampleLevel(samplerPointClamp, t_i, 0).x;
    float weight_i = (coc_i >= coc_o) ? 1.0f : saturate(abs(coc_i) / maxBlur);
    //weight_i *= abs(coc_i) >= length(diskOffset * min(abs(coc_o), maxBlur)) ? 1.0f : saturate(abs(coc_i) / maxBlur) * 0.5f;
    //float weight_i = (coc_i >= coc_o) ? 1.0f : 0.0f;
    
    float4 color_i = blurInputTex.SampleLevel(samplerLinearClamp, t_i, 0);
    
    color += color_i * weight_i;
    weightAll += weight_i;
  }
  
  color /= max(0.0001f, weightAll);
  
  return color;
}
    
    ]]>
  </shader>

  <technique name="UnfocusedDiskBlur">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="UnfocusedDiskBlurPS"/>
    </pass>
  </technique>


  <header>
    <![CDATA[
    
    struct BokehPoint
    {
      float2 pos;
      float  size;
      float3 color;
    };
    
    ]]>
  </header>

  <variable type="AppendStructuredBuffer" format="BokehPoint" name="bokehPointsBuffer"/>
  <variable type="Texture2D" name="computeBokehInTex"/>
  
  <variable type="cbuffer" name="cb_computeBokeh">
    <variable type="float" name="illumThreshold"/>
    <variable type="float" name="minBokehSize"/>
    <variable type="float" name="maxBokehSize"/>
    <variable type="float" name="bokehSizeScale"/>
  </variable>

  <shader>
    <![CDATA[
    
#define BOKEH_COMPUTE_NUM_SAMPLES 9

float4 ComputeBokehPointsPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 t_o = vsOut.pos.xy * texelSize;
  
  float3 color_o = computeBokehInTex.SampleLevel(samplerLinear, t_o, 0).rgb;
  float ilum_o = GetIlluminance(color_o);
  
  static const float2 texOffsets[] = 
  {
    float2(-1.5f, -1.5f), float2(0.5f, -1.5f), float2(2.0f, -1.5f),
    float2(-1.5f,  0.5f), float2(0.5f,  0.5f), float2(2.0f,  0.5f),
    float2(-1.5f,  2.0f), float2(0.5f,  2.0f), float2(2.0f,  2.0f)
  };
  
  float3 avgColor = 0.0f;
  
  [unroll] for(int i = 0; i < BOKEH_COMPUTE_NUM_SAMPLES; ++i)
  {
    float2 t_i = t_o + texOffsets[i] * texelSize;
    float3 sampleColor = computeBokehInTex.SampleLevel(samplerLinearClamp, t_i, 0).rgb;
    avgColor += sampleColor;
  }
  avgColor /= BOKEH_COMPUTE_NUM_SAMPLES;
  
  float avgIlum = GetIlluminance(avgColor);
  
  float centerCoC = cocTex.SampleLevel(samplerPoint, t_o, 0).x;
  
  float4 outColor = float4(color_o, 1.0f);
  
  float bokehSize = centerCoC * bokehSizeScale;
  
  if(ilum_o - avgIlum > illumThreshold && abs(bokehSize) >= minBokehSize)
  {
    BokehPoint bokehPoint;
    bokehPoint.pos = vsOut.pos.xy * texelSize * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f);
    bokehPoint.size = min(bokehSize, maxBokehSize);
    bokehPoint.color = color_o;
    bokehPointsBuffer.Append(bokehPoint);
    
    outColor = 0.0f;
  }
  
  return outColor;
}
    
    ]]>
  </shader>

  <technique name="ComputeBokehPoints">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ComputeBokehPointsPS"/>
    </pass>
  </technique>


  <variable type="StructuredBuffer" format="BokehPoint" name="bokehPointsBufferForRender"/>
  <variable type="Texture2D" name="bokehTex"/>

  <variable type="cbuffer" name="cb_renderBokeh">
    <variable type="float" name="bokehIlluminanceScale"/>
    <variable type="float3" name="_pad_renderBokeh"/>
  </variable>
  
  <shader>
    <![CDATA[
  
struct RenderBokehVSOut
{
  float2 pos : POSITION;
  float size : SIZE;
  float3 color : COLOR;
};
  
void RenderBokehVS(
  uint vertexID : SV_VertexID,
  out RenderBokehVSOut vsOut)
{
  BokehPoint bokehPoint = bokehPointsBufferForRender[vertexID];
  
  vsOut.pos.xy = bokehPoint.pos.xy;
  
  vsOut.size = bokehPoint.size;
  
  vsOut.color = bokehPoint.color;
}

struct RenderBokehGSOut
{
  float4 pos : SV_POSITION;
  float2 tex : TEXCOORD;
  float size : SIZE;
  float4 color : COLOR;
};

[maxvertexcount(4)]
void RenderBokehGS(
  point RenderBokehVSOut inPoints[1],
  inout TriangleStream<RenderBokehGSOut> outStream)
{
  static const float2 offsets[] = 
  {
    float2(-1.0f,  1.0f),
    float2( 1.0f,  1.0f),
    float2(-1.0f, -1.0f),
    float2( 1.0f, -1.0f)
  };
  
  static const float2 texCoords[] = 
  {
    float2(0.0f, 0.0f),
    float2(1.0f, 0.0f),
    float2(0.0f, 1.0f),
    float2(1.0f, 1.0f)
  };
  
  float2 posOffsetScale = abs(inPoints[0].size) * texelSize * 2.0f;
  
  RenderBokehGSOut gsOut;
  gsOut.pos.zw = float2(0.0f, 1.0f);
  gsOut.color.rgb = inPoints[0].color;
  gsOut.color.a = 1.0f / (PI * inPoints[0].size * inPoints[0].size) * bokehIlluminanceScale;
  gsOut.size = inPoints[0].size;
  
  for(uint i = 0; i < 4; ++i)
  {
    gsOut.pos.xy = inPoints[0].pos + offsets[i] * posOffsetScale;
    gsOut.tex = texCoords[i];
    
    outStream.Append(gsOut);
  }
  
  outStream.RestartStrip();
}

struct RenderBokehPSOut
{
  float4 color0 : SV_TARGET0;
  //float4 color1 : SV_TARGET1;
};

RenderBokehPSOut RenderBokehPS(
  RenderBokehGSOut gsOut)
{
  RenderBokehPSOut psOut;
  psOut.color0 = 0.0f;
  //psOut.color1 = 0.0f;

  float3 color = bokehTex.Sample(samplerLinear, gsOut.tex).rgb;
  
  
  //if(gsOut.size > 0.0f)
    psOut.color0 = float4(color * gsOut.color.rgb, gsOut.color.a);
  //else
   // psOut.color1 = float4(color * gsOut.color.rgb, gsOut.color.a);
    
    
  return psOut;
}

    ]]>
  </shader>

  <variable type='BlendState' name='accumBlend'>
    <state name="blendRTDesc" index="0">
      <state name="blendEnable" value="true"/>
      <state name="srcBlend" value="SRC_ALPHA"/>
      <state name="dstBlend" value="ONE"/>
      <state name="dstBlendAlpha" value="ZERO"/>
    </state>
    <state name="blendRTDesc" index="1">
      <state name="blendEnable" value="true"/>
      <state name="srcBlend" value="SRC_ALPHA"/>
      <state name="dstBlend" value="ONE"/>
      <state name="dstBlendAlpha" value="ZERO"/>
    </state>
  </variable>
    
  <technique name="RenderBokeh">
    <pass>
      <state value="disableDepth"/>
      <state value="accumBlend"/>
      <vs entry="RenderBokehVS"/>
      <gs entry="RenderBokehGS"/>
      <ps entry="RenderBokehPS"/>
    </pass>
  </technique>
  

  <variable type="Texture2D" name="nearBlurTex"/>
  <variable type="Texture2D" name="farBlurTex"/>
  <variable type="Texture2D" name="bokehLayerTex"/>

  <shader>
    <![CDATA[
    
float4 RecombinePS(PostProcessVSOut vsOut) : SV_TARGET
{
  float coc = cocTex.SampleLevel(samplerPoint, vsOut.tex, 0).x;
  
  float4 sharp = sceneTex.SampleLevel(samplerPoint, vsOut.tex, 0);
  float4 far = farBlurTex.SampleLevel(samplerLinear, vsOut.tex, 0);
  float4 near = nearBlurTex.SampleLevel(samplerLinear, vsOut.tex, 0);
  
  float farMask = far.a;
  float focalMask = 1.0f - saturate((abs(coc) - 0.5f) / maxBlur);
  float nearMask = near.a;
  
  float4 color = 0.0f;
  
  color.rgb = far.rgb / (far.a + 0.001f);
  
  float Blend = far.a;
	// Magic function to transform alpha into smooth blend function against in-focus skybox.
	Blend = sqrt(Blend);
	Blend = sqrt(Blend);
	Blend = Blend * Blend * (3.0 - 2.0 * Blend);
  color.rgb = lerp(sharp.rgb, color.rgb, Blend);
    
  float Smash = 0.25;
	//focalMask = saturate((focalMask - (1.0 - Smash)) * rcp(Smash));
	//focalMask *= focalMask;
  focalMask = pow(focalMask, 4.0f);
	color.rgb = lerp(color.rgb, sharp.rgb, focalMask);
  
  float3 FrontLayer = near.rgb / (near.a + 0.001f);

	// Layer 3: on top of that blend the front half res layer	
	color.rgb = lerp(color.rgb, FrontLayer, saturate(nearMask * 1));
  
  float3 bokehColor = bokehLayerTex.SampleLevel(samplerPoint, vsOut.tex, 0).rgb;
  color.rgb += bokehColor;
  
  return float4(color.rgb, 1.0);
}
    
    ]]>
  </shader>

  <technique name="Recombine">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="RecombinePS"/>
    </pass>
  </technique>
  
</effect>
