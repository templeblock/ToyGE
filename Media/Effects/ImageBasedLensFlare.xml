<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>
  <include name="Util.xml"/>
  <include name="View.xml"/>

  <variable type="Texture2D" name="sceneTex"/>
  
  <variable type="cbuffer" name="cb_brightPass">
    <variable type="float" name="brightPassThreshold"/>
  </variable>
    
  <shader>
    <![CDATA[
  
float4 BrightPassPS(PostProcessVSOut vsOut) : SV_TARGET
{
    float3 color = sceneTex.SampleLevel(samplerPoint, vsOut.tex, 0).xyz;
    float ilum = GetIlluminance(color);
    if(ilum < brightPassThreshold)
        discard;
        
    return float4(color, 0.0f);
}
  
    ]]>
  </shader>
  
  <technique name="BrightPass">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="BrightPassPS"/>
    </pass>
  </technique>
  
  
  <variable type="Texture2D" name="brightPassTex"/>
  
  <shader>
    <![CDATA[
    
float BorderFade(float2 pos)
{
    float fade = saturate(1.0f - dot(pos, pos));
    return fade * fade;
}
    
float4 LensFlareSetupPS(PostProcessVSOut vsOut) : SV_TARGET
{
    float2 posH = vsOut.tex * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f);
    float borderFade = BorderFade(posH);
    
    borderFade *= BorderFade(0.8 * posH);
    
    return brightPassTex.SampleLevel(samplerLinear, vsOut.tex, 0) * borderFade;
}
    
    ]]>
  </shader>

  <technique name="LensFlareSetup">
    <pass>
      <state value="disableDepth"/>
      <state value="bs_srcOne_dstOne_add"/>
      <vs entry="PostProcessVS"/>
      <ps entry="LensFlareSetupPS"/>
    </pass>
  </technique>

  <header>
    <![CDATA[
    
    struct SpritePoint
    {
      float2 pos;
      float3 color;
    };
    
    ]]>
  </header>

  <variable type="AppendStructuredBuffer" format="SpritePoint" name="spPointsBuf"/>
  <variable type="Texture2D" name="setupTex"/>

  <variable type="cbuffer" name="cb_spPoints">
    <variable type="float" name="spriteThreshold"/>
  </variable>

  <shader>
    <![CDATA[
    
#define TILE_SIZE 9
    
void ExtractSpritePointsPS(PostProcessVSOut vsOut)
{
    uint2 tileLU = uint2(vsOut.pos.xy) * TILE_SIZE;
    
    float4 colorSum = 0.0f;
    
    [unroll] for(uint i = 0; i < TILE_SIZE; ++i)
    {
        [unroll] for(uint j = 0; j < TILE_SIZE; ++j)
        {
            float4 sampleColor = setupTex.Load(uint3(tileLU.x + i, tileLU.y + j, 0));
            colorSum += sampleColor;
        }
    }
    
    colorSum /= TILE_SIZE * TILE_SIZE;
    
    float ilum = GetIlluminance(colorSum.xyz);
    if(ilum >= spriteThreshold)
    {
        SpritePoint sp;
        sp.pos = vsOut.tex * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f);
        sp.color = colorSum.xyz;
        
        spPointsBuf.Append(sp);
    }
}
    
    ]]>
  </shader>

  <technique name="ExtractSpritePoints">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ExtractSpritePointsPS"/>
    </pass>
  </technique>


  <variable type="StructuredBuffer" format="SpritePoint" name="spPointsRenderBuf"/>
  <variable type="Texture2D" name="lensTex"/>

  <variable type="cbuffer" name="cb_lensBlur">
    <variable type="float4" name="texSize"/>
    <variable type="float" name="flareIntensity"/>
  </variable>
  
  <shader>
    <![CDATA[
    
struct LensBlurVSOut
{
    float2 pos : POSITION;
    float size : SIZE;
    float3 color : COLOR;
};
  
void LensBlurVS(
    uint vertexID : SV_VertexID,
    out LensBlurVSOut vsOut)
{
    SpritePoint sp = spPointsRenderBuf[vertexID];
  
    vsOut.pos.xy = sp.pos;
  
    float spMinSize = TILE_SIZE * 1 / texSize.x;
    float spMaxSize = TILE_SIZE * 32 / texSize.x;
  
    float d = sqrt( max(1e-4, dot(vsOut.pos, vsOut.pos)) );
    vsOut.size = lerp(spMinSize, spMaxSize, saturate(d));
  
    vsOut.color = sp.color;
}

struct LensBlurGSOut
{
    float4 pos : SV_POSITION;
    float2 tex : TEXCOORD;
    float4 color : COLOR;
};

[maxvertexcount(4)]
void LensBlurGS(
    point LensBlurVSOut inPoints[1],
    inout TriangleStream<LensBlurGSOut> outStream)
{
    static const float2 offsets[] = 
    {
      float2(-1.0f,  1.0f),
      float2( 1.0f,  1.0f),
      float2(-1.0f, -1.0f),
      float2( 1.0f, -1.0f)
    };
  
    static const float2 texCoords[] = 
    {
      float2(0.0f, 0.0f),
      float2(1.0f, 0.0f),
      float2(0.0f, 1.0f),
      float2(1.0f, 1.0f)
    };
  
    float2 posOffsetScale = abs(inPoints[0].size) * float2(1.0f, texSize.x / texSize.y);
  
    float pixelSize = inPoints[0].size * texSize.x;
  
    LensBlurGSOut gsOut;
    gsOut.pos.zw = float2(0.0f, 1.0f);
    gsOut.color.rgb = inPoints[0].color;
    gsOut.color.a = 1.0f / (PI * pixelSize * pixelSize) * flareIntensity * GetIlluminance(gsOut.color.rgb);
  
    for(uint i = 0; i < 4; ++i)
    {
      gsOut.pos.xy = inPoints[0].pos + offsets[i] * posOffsetScale;
      gsOut.tex = texCoords[i];
    
      outStream.Append(gsOut);
    }
  
    outStream.RestartStrip();
}


float4 LensBlurPS(LensBlurGSOut gsOut) : SV_TARGET
{
    float3 color = lensTex.Sample(samplerLinear, gsOut.tex).rgb;

    color *= gsOut.color.rgb;
    
    return float4(color, gsOut.color.a);
}
    
    ]]>
  </shader>

  <technique name="LensBlur">
    <pass>
      <state value="disableDepth"/>
      <state value="bs_srcAlpha_dstOne_add"/>
      <vs entry="LensBlurVS"/>
      <gs entry="LensBlurGS"/>
      <ps entry="LensBlurPS"/>
    </pass>
  </technique>
  

</effect>