<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>
  <include name="BlurConfig.xml"/>

  <variable type="Texture2D" name="sceneTex"/>
  <variable type="Texture2D" name="depthLinearTex"/>
  
  <variable type="SamplerState" name="samPoint">
    <state name='filter' value='MIN_MAG_MIP_POINT'/>
    <state name='addressU' value='CLAMP'/>
    <state name='addressV' value='CLAMP'/>
  </variable>
  
  <variable type="SamplerState" name="samLinear">
    <state name='filter' value='MIN_MAG_MIP_LINEAR'/>
    <state name='addressU' value='CLAMP'/>
    <state name='addressV' value='CLAMP'/>
  </variable>

  <variable type='cbuffer' name='cb_downSampleAndPack'>
    <variable type='float' name='diameter'/>
    <variable type='float' name='focusZ'/>
    <variable type='float' name='pad'/>
    <variable type='float' name='maxCoC'/>
    <variable type='float' name='nearStart'/>
    <variable type='float' name='nearEnd'/>
    <variable type='float' name='farStart'/>
    <variable type='float' name='farEnd'/>
  </variable>
  
  <shader>
    <![CDATA[

float4 ComputeCoCPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float3 sceneColor = sceneTex.SampleLevel(samPoint, vsOut.tex, 0).xyz;
  float z = depthLinearTex.SampleLevel(samPoint, vsOut.tex, 0).x;
  
  float coc = 0.0f;
  if(z <= nearEnd)
  {
    coc = lerp(maxCoC, 0.0f, (z - nearStart) / (nearEnd - nearStart));
    coc = clamp(coc, 0.0f, maxCoC);
  }
  else if(z >= farStart)
  {
    coc = lerp(0.0f, maxCoC, (z - farStart) / (farEnd - farStart));
    coc = -clamp(coc, 0.0f, maxCoC);
  }
  
  return float4(sceneColor, coc);
}

    ]]>
  </shader>
  
  <technique name='ComputeCoC'>
    <pass>
      <state value='disableDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='ComputeCoCPS'/>
    </pass>
  </technique>


  <variable type='Texture2D' name='blurInputTex'/>
  <variable type='Texture2D' name='nearFieldTex'/>
  <variable type='cbuffer' name='cb_blur'>
    <variable type='float2' name='quadSize'/>
  </variable>
  
  <shader>
    <![CDATA[
  
#define BLUR_RADIUS 10
  
struct BlurPsOut
{
  float4 nearColor : SV_TARGET0;
  float4 blurColor : SV_TARGET1;
};
  
BlurPsOut BlurPS(PostProcessVSOut vsOut)
{
  BlurPsOut psOut;
  psOut.nearColor = 0.0f;
  psOut.blurColor = 0.0f;
  
  float2 texelSize = 1.0f / quadSize;
  float2 t0 = vsOut.pos.xy * texelSize;
  float4 p0 = blurInputTex.SampleLevel(samPoint, t0, 0);
  
  float weights[MAX_BLUR_RADIUS + 1] = (float[MAX_BLUR_RADIUS + 1])gaussTable;
  weights[BLUR_RADIUS + 1] = 0.0f;
  
  float blurWeightsAll = 0.0f;
  float nearWeightsAll = 0.0f;
  
  float stride = maxCoC / BLUR_RADIUS;
  
#ifdef BLUR_X
  float2 direction = float2(1.0f, 0.0f);
#else
  float2 direction = float2(0.0f, 1.0f);
#endif
  direction *= stride;
  
  [unroll] for(int i = -BLUR_RADIUS; i <= BLUR_RADIUS; ++i)
  {
    float2 ti = t0 + i * direction * texelSize;
    float4 pi = blurInputTex.SampleLevel(samLinear, ti, 0);
    
    float blurWeight = 0.0f;
    float blurWeightGauss = weights[int( clamp(float(abs(i)) / (0.001f + abs(pi.w)) * float(BLUR_RADIUS), 0.0f, BLUR_RADIUS + 1) )];
    //float blurWeightGauss = weights[int( clamp(float(abs(i)) / (BLUR_RADIUS) * float(BLUR_RADIUS), 0.0f, BLUR_RADIUS + 1) )];
    blurWeight = 
      float(pi.w <= 0.0f) * 
      saturate(abs(p0.w) - abs(pi.w) + 1.5f) * 
      blurWeightGauss;
    
    blurWeight = lerp(blurWeight, 1.0f, saturate(p0.w * 4.0f));
    psOut.blurColor.xyz += pi.xyz * blurWeight;
    blurWeightsAll += blurWeight;
    
    
    float4 nearInput = 0.0f;
#ifdef BLUR_X
    nearInput.w = float(abs(i) <= pi.w) * saturate(pi.w / maxCoC * 4.0f);
    nearInput.w *= nearInput.w;
    nearInput.w *= nearInput.w;
    nearInput.xyz = pi.xyz * nearInput.w;
#else
    nearInput = nearFieldTex.SampleLevel(samLinear, ti, 0);
#endif
    
    float nearWeight = 0.0f;
    nearWeight = float(abs(i) < maxCoC);
    psOut.nearColor += nearWeight * nearInput;
    nearWeightsAll += nearWeight;
  }
  
  psOut.blurColor /= (0.0001f + blurWeightsAll);
#ifdef BLUR_X
  psOut.blurColor.w = p0.w;
#else
  psOut.blurColor.w = 1.0f;
#endif
  
  psOut.nearColor /= (0.0001f + nearWeightsAll);
  
  return psOut;
}
  
    ]]>
  </shader>

  <technique name='BlurX'>
    <pass>
      <macro name='BLUR_X'/>
      <state value='disableDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='BlurPS'/>
    </pass>
  </technique>
  <technique name='BlurY'>
    <pass>
      <state value='disableDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='BlurPS'/>
    </pass>
  </technique>


  <variable type='Texture2D' name='packTex'/>
  <variable type='Texture2D' name='blurTex'/>
  
  <shader>
    <![CDATA[
    
float4 CompositePS(PostProcessVSOut vsOut) : SV_TARGET
{
  float4 pack = packTex.SampleLevel(samPoint, vsOut.tex, 0);
  float3 sharp = pack.xyz;
  float3 blur = blurTex.SampleLevel(samLinear, vsOut.tex, 0).xyz;
  float4 near = nearFieldTex.SampleLevel(samLinear, vsOut.tex, 0);
  
  float a = saturate(1.5f * near.w);
  near.xyz = near.xyz * (a / max(near.w, 0.001));
  near.w = a;
  
  float normRadius = pack.w / maxCoC;
  if(normRadius > 0.1)
  {
    normRadius = min(1.0f, normRadius * 1.5f);
  }
  float3 result = lerp(sharp, blur, abs(normRadius)) * (1.0f - near.w) + near.xyz;
  //float3 result = lerp(sharp, blur, abs(normRadius));
  return float4(result, 1.0f);
}

    ]]>
  </shader>

  <technique name='Composite'>
    <pass>
      <state value='disableDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='CompositePS'/>
    </pass>
  </technique>

</effect>