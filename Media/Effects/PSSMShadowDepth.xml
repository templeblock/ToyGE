<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="ESMDefines.xml"/>
  <include name="Util.xml"/>
  <include name="CSMConfig.xml"/>
  <include name="CommonState.xml"/>
  <include name="Material.xml"/>
  <include name="Lighting.xml"/>
  
  <variable type='cbuffer' name='cb_vs_perObj'>
    <variable type='float4x4' name='world'/>
  </variable>

  <variable type='cbuffer' name='cb_pssm_vs_perFrame'>
    <!--<variable type='float4x4' name='lightView'/>-->
    <variable type='float4x4' name='lightView'/>
  </variable>

  <variable type='cbuffer' name='cb_pssm_gs_perFrame'>
    <variable type='float4x4' name='lightCrop'/>
    <!--<variable type='uint4' name='numSplits'/>
    <variable type='float4' name='lightMaxDist'/>-->
  </variable>
  
  <variable type='Texture2D' name='opacityTex' />

  <shader>
    <![CDATA[
struct PSSMVSIn
{
	  float3 pos : POSITION;
    
#ifdef RENDER_RSM
    float3 normal : NORMAL;
#endif

#ifdef MAT_UV_COORD
    float3 tex : TEXCOORD;
#endif
};

struct PSSMVSOut
{
	float4 posH : SV_POSITION;
  float3 posW : POSITION_W;
#ifdef RENDER_RSM
    float3 normal : NORMAL;
#endif
  
#ifdef MAT_UV_COORD
  float3 tex : TEXCOORD;
#endif
};

PSSMVSOut PSSM_VS(PSSMVSIn vsIn)
{
	PSSMVSOut vsOut;
  
  vsOut.posW = mul(float4(vsIn.pos, 1.0f), world).xyz;

	//float4x4 worldView = mul( world, lightView );
  vsOut.posH = mul(float4(vsOut.posW, 1.0f), lightView);
  vsOut.posH = mul(vsOut.posH, lightCrop);
  
#ifdef RENDER_RSM
  vsOut.normal = mul(float4(vsIn.normal, 0.0f), world).xyz;
#endif
  
#ifdef MAT_UV_COORD
  vsOut.tex = vsIn.tex;
#endif

	return vsOut;
}

struct PSSMGSOut
{
  float4 posH : SV_POSITION;
  uint rtIndex : SV_RenderTargetArrayIndex;
};

/*
[maxvertexcount(MAX_NUM_SPLITS * 3)]
void PSSM_GS(
  triangle PSSMVSOut vsOut[3],
  inout TriangleStream<PSSMGSOut> output)
{
  PSSMGSOut gsOut;
  for(uint splitIndex = 0; splitIndex < numSplits.x; ++splitIndex)
  {
    float4x4 crop = lightCrop[splitIndex];
    for(uint i = 0; i < 3; ++i)
    {
      gsOut.posH = mul(vsOut[i].posLi, crop);
      gsOut.rtIndex = splitIndex;
      output.Append(gsOut);
    }
    output.RestartStrip();
  }
}
*/

void PSSM_PS(
    PSSMVSOut vsOut,
    out float outDepth : SV_TARGET0
#ifdef RENDER_RSM
    ,
    out float3 outNormal : SV_TARGET1,
    out float3 outDiffuseColor : SV_TARGET2
#endif
    )
{
#ifdef MAT_OPACITYMASK_TEX
    float opacity = opacityTex.Sample(samplerLinear, vsOut.tex.xy).x;
    clip(opacity - 0.1f);
#endif
  
#ifdef RENDER_RSM
    float3 normal = normalize(vsOut.normal);
    outNormal = normal * 0.5f + 0.5f;
    
    float3 inRadiance = ComputeInLightRadiance(vsOut.posW, normal);
    
    float3 baseColor = GetBaseColor
    (
    #ifdef MAT_UV_COORD
        vsOut.tex
    #endif
    );
    float metallic = GetMetallic();
    outDiffuseColor = GetDiffuseColor(baseColor, metallic) * inRadiance;
#endif

    outDepth = vsOut.posH.z;
}

/*
float2 PSSM_PS_VSM(PSSMVSOut gsOut) : SV_TARGET
{
  float z = gsOut.posH.z;
	return float2(z, z * z);
}

float PSSM_PS_EVSM(PSSMVSOut gsOut) : SV_TARGET
{
   float z = gsOut.posH.z;
   return z;
}

float2 PSSM_PS_EVSM2(PSSMVSOut gsOut) : SV_TARGET
{
  float z = gsOut.posH.z;
  float zWarp = WarpDepth2(z);
	return float2(zWarp, zWarp * zWarp);
}

float4 PSSM_PS_EVSM4(PSSMVSOut gsOut) : SV_TARGET
{
  float z = gsOut.posH.z;
  float2 zWarp = WarpDepth4(z);
	return float4(zWarp.x, zWarp.x * zWarp.x, zWarp.y, zWarp.y * zWarp.y);
}

float PSSM_PS_ESM(PSSMVSOut gsOut) : SV_TARGET
{
  float z = gsOut.posH.z;
	return z * ESM_C * lightMaxDist.x;
}

float4 PSSM_PS_SAVSM(PSSMVSOut gsOut) : SV_TARGET
{
  float z = gsOut.posH.z;
  float2 moments = float2(z, z * z) - 0.5f;
	return DistributePrecision(moments, 1 << 8);
}
*/

    ]]>
  </shader>

  <technique name='PSSM'>
    <pass>
      <vs entry='PSSM_VS'/>
      <ps entry='PSSM_PS'/>
    </pass>
  </technique>

  <!--<technique name='PSSM_OPACITYTEX'>
    <pass>
      <macro name='OPACITY_TEX'/>
      <vs entry='PSSM_VS'/>
      <ps entry='PSSM_PS'/>
    </pass>
  </technique>-->

</effect>