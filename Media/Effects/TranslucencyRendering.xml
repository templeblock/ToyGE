<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name='Lighting.xml'/>
  <include name='Material.xml'/>
  <include name='View.xml'/>
  <include name='ScreenSpaceTracing.xml'/>
  
  <variable type='cbuffer' name='cb_translucencyVS_perObj'>
    <variable type='float4x4' name='world'/>
  </variable>

  <variable type='RasterizerState' name='cullNone'>
    <state name='cullMode' value='NONE'/>
  </variable>
  
  <variable type='DepthStencilState' name='lessEqualDepth'>
    <state name='depthWriteMask' value='ZERO'/>
    <state name='depthFunc' value='LESS_EQUAL'/>
  </variable>

  <shader>
    <![CDATA[

struct TranslucencyVSIn
{
    float3 pos : POSITION;
    
#ifdef MAT_UV_COORD
	  float3 tex : TEXCOORD;
#endif

	  float3 normal : NORMAL;
    
#ifdef MAT_NORMAL_TEX
	  float3 tangent : TANGENT;
#endif
};

struct TranslucencyVSOut
{
    float3 posW : POSITION_W;
    float3 posV : POSITION_V;
    float4 posH : SV_POSITION;
    
#ifdef MAT_UV_COORD
	  float3 tex : TEXCOORD;
#endif

    float3 normalW : NORMAL;
  
#ifdef MAT_NORMAL_TEX
	  float3 tangentW : TANGENT;
#endif
};

TranslucencyVSOut TranslucencyVS(TranslucencyVSIn vsIn)
{
    TranslucencyVSOut vsOut;
    vsOut.posW = mul(float4(vsIn.pos, 1.0f), world).xyz;
    vsOut.posV = mul(float4(vsOut.posW, 1.0f), view).xyz;
    vsOut.posH = mul(float4(vsOut.posV, 1.0f), proj);
    
#ifdef MAT_UV_COORD
    vsOut.tex = vsIn.tex;
#endif
    vsOut.normalW = mul(float4(vsIn.normal, 0.0f), world).xyz;
#ifdef NORMAL_TEX
    vsOut.tangentW = mul(float4(vsIn.normal, 0.0f), world).xyz;
#endif
  
    return vsOut;
}

float3 ComputeLigting(Material mat, TranslucencyVSOut vsOut)
{
  float3 normal = mat.normal;

  float shadow = ComputeShadow(vsOut.posW, vsOut.posV.z);

  float3 n = normal;
  float3 l = -GetLightDir(vsOut.posW);
	float3 v = normalize(cameraPos - vsOut.posW);
	float3 h = normalize(l + v);

  float3 light_in = ComputeInLightRadiance(vsOut.posW, n);
  
  light_in *= shadow;
  
  float3 diffColor = mat.baseColor - mat.baseColor * mat.metallic;
  float3 specColor = lerp(0.03f, baseColor, metallic);
  
  float3 color = 0.0f;
    
  float D = NDF_GGX(n, h, roughness);
  float3 F = Fresnel_Schlick(v, h, specColor);
  float G = G_Smith(n, l, v, roughness);
  float n_dot_l = max(1e-6, dot(n, l));
  float n_dot_v = max(1e-6, dot(n, v));
  color += light_in * D * F * G / (4 * n_dot_l * n_dot_v);;

  color += diffColor * light_in / PI * mat.opacity;
  
  return color;
}


    ]]>
  </shader>

  <variable type="RWStructuredBuffer" format="float" name="oitCounter" register="u0"/>
  <variable type="RWTexture2D" format="int" name="listHead"/>
  <variable type="RWTexture2D" format="float3" name="listTransmittance"/>
  <variable type="RWTexture2D" format="float3" name="listLighting"/>
  <variable type="RWTexture2D" format="float2" name="listDepthLink"/>

  <variable type="cbuffer" name="cb_oit">
    <variable type="int2" name="texSize"/>
  </variable>

  <shader>
    <![CDATA[
    
void OITSceneRenderingPS(TranslucencyVSOut vsOut)
{

#ifdef MAT_OPACITYMASK_TEX
    float opacityMask = GetOpacityMask(vsOut.tex.xy);
    clip(opacityMask - 0.1f);
#endif
    
    Material mat = GetMeterial
    (
    #ifdef MAT_UV_COORD
        vsOut.tex,
    #endif
        vsOut.normalW
    #ifdef MAT_NORMAL_TEX
        , vsOut.tangent
    #endif
    );

  
  float3 diffColor = mat.baseColor - mat.baseColor * mat.metallic;
  
  float3 transmittance = diffColor * (1.0f - mat.opacity);
  
#ifdef OIT_EMBIENT
  float3 embient = 0.2f;
  float3 lighting = diffColor * embient * opacity;
#else
  float3 lighting = ComputeLigting(mat, vsOut);
#endif
  
  int newNodeIndex = oitCounter.IncrementCounter();
  
  int oldNodeIndex;
  InterlockedExchange(listHead[int2(vsOut.posH.xy)], newNodeIndex, oldNodeIndex);
  
  int2 newNodePos = int2( uint(newNodeIndex) % uint(texSize.x), uint(newNodeIndex) / uint(texSize.x) );
  listTransmittance[newNodePos] = transmittance;
  listLighting[newNodePos] = lighting;
  listDepthLink[newNodePos] = float2(vsOut.posH.z, oldNodeIndex);
}
    
    ]]>
  </shader>

  <variable type='DepthStencilState' name='noDepthWrite'>
    <state name='depthWriteMask' value='ZERO'/>
  </variable>

  <technique name="OITSceneRendering">
    <pass>
      <state value="noDepthWrite"/>
      <vs entry="TranslucencyVS"/>
      <ps entry="OITSceneRenderingPS"/>
    </pass>
  </technique>

  <technique name="OITSceneRenderingDualFace">
    <pass>
      <state value="noDepthWrite"/>
      <state value="cullNone"/>
      <vs entry="TranslucencyVS"/>
      <ps entry="OITSceneRenderingPS"/>
    </pass>
  </technique>


  <shader>
    <![CDATA[
    
float4 RefractionBackFacePS(TranslucencyVSOut vsOut) : SV_TARGET
{
  float4 result;
  
  result.x = (vsOut.posV.z - cameraNearFar.x) / (cameraNearFar.y - cameraNearFar.x);
  
  float3 normal = GetNormal
  (
  #ifdef MAT_UV_COORD
    vsOut.tex,
  #endif
    vsOut.normalW
  #ifdef MAT_NORMAL_TEX
    , vsOut.tangent
  #endif
  );
  result.yzw = normal;
  
  return result;
}
    
    ]]>
  </shader>

  <variable type='RasterizerState' name='backFaceRasterizer'>
    <state name='cullMode' value='FRONT'/>
  </variable>

  <variable type='DepthStencilState' name='greaterDepth'>
    <state name='depthFunc' value='GREATER'/>
  </variable>

  <technique name="RefractionBackFace">
    <pass>
      <state value="backFaceRasterizer"/>
      <state value="greaterDepth"/>
      <vs entry="TranslucencyVS"/>
      <ps entry="RefractionBackFacePS"/>
    </pass>
  </technique>


  <variable type='Texture2D' name='backgroundTex' />
  <variable type='Texture2D' name='backFaceInfoTex' />
  <variable type='Texture2D' name='linearDepthTex' />
  <variable type='TextureCube' name='envMap'/>

  <shader>
    <![CDATA[
 
float3 ComputeRefractionColor(Material mat, TranslucencyVSOut vsOut)
{
  float3 normal = mat.normal;

  float3 n = normal;
	float3 v = normalize(cameraPos - vsOut.posW);
  
  float3 texDims;
  backgroundTex.GetDimensions(0, texDims.x, texDims.y, texDims.z);
  
  float3 refractionColor = 0.0f;
  
#ifndef DUAL_FACE
  
  float refractionIndex = mat.refractionIndex;
  float3 refractDirW = refract(-v, n, 1.0f / refractionIndex);
  float3 refractDirV = mul(float4(refractDirW, 0.0f), view).xyz;
  
  bool bHit;
  float2 hitTexCoord;
  float3 hitPosT;
  float3 hitPosV;
  float2 stepT;
  
  bHit = ScreenSpaceTracing(
           vsOut.posV,
           refractDirV,
           proj,
           cameraNearFar.xy,
           linearDepthTex,
           texDims.xy,
           100, //maxSteps
           1.0f,
           0.0f,
           hitTexCoord,
           hitPosV,
           stepT);
   
  refractionColor = backgroundTex.SampleLevel(samplerLinear, hitTexCoord, 0).xyz;
   
#else //Refraction DualFace 

  float refractionIndex = mat.refractionIndex;
  float3 refractDirW = refract(-v, n, 1.0f / refractionIndex);
  float3 refractDirV = mul(float4(refractDirW, 0.0f), view).xyz;
  
  bool bHit;
  float2 hitTexCoord;
  float3 hitPosT;
  float3 hitPosV;
  float2 stepT;
  
  //Tracing To Backface
  bHit = ScreenSpaceTracing(
           vsOut.posV,
           refractDirV,
           proj,
           cameraNearFar.xy,
           backFaceInfoTex,
           texDims.xy,
           100, //maxSteps
           1.0f,
           0.0f,
           hitTexCoord,
           hitPosV,
           stepT);
           
  float4 backFaceInfo = backFaceInfoTex.SampleLevel(samplerPoint, hitTexCoord, 0);
  float3 backFaceHitNormalW = -backFaceInfo.yzw;
  if(!any(backFaceHitNormalW))
  {
    hitTexCoord -= stepT / texDims.xy;
    backFaceHitNormalW = -backFaceInfoTex.SampleLevel(samplerPoint, hitTexCoord, 0).yzw;
  }
   
  float3 refractDirW_B = refract(refractDirW, backFaceHitNormalW, refractionIndex);
  if(any(refractDirW_B))
    refractDirW = refractDirW_B;
  refractDirV = mul(float4(refractDirW, 0.0f), view).xyz;
     
  //Tracing To Scene
  bHit = ScreenSpaceTracing(
          hitPosV,
          refractDirV,
          proj,
          cameraNearFar.xy,
          linearDepthTex,
          texDims.xy,
          100, //maxSteps
          1.0f,
          0.0f,
          hitTexCoord,
          hitPosV,
          stepT);
            
  refractionColor = backgroundTex.SampleLevel(samplerLinear, hitTexCoord, 0.0f).xyz;
  
#endif //End Refraction Dual Face
  
  return refractionColor;
}
 
 
float4 RefractionPS(TranslucencyVSOut vsOut) : SV_TARGET
{
#ifdef MAT_OPACITYMASK_TEX
  float opacityMask = GetOpacityMask(vsOut.tex.xy);
  clip(opacityMask - 0.1f);
#endif
    
    Material mat = GetMeterial
    (
    #ifdef MAT_UV_COORD
        vsOut.tex,
    #endif
        vsOut.normalW
    #ifdef MAT_NORMAL_TEX
        , vsOut.tangent
    #endif
    );
  
  float3 diffColor = mat.baseColor - mat.baseColor * mat.metallic;  
  
  float3 refractionColor = ComputeRefractionColor(mat, vsOut);

  float3 transColor = refractionColor * diffColor * (1.0f - opacity);
  
  return float4(transColor, 1.0f);
}
    
    ]]>
  </shader>

  <technique name="Refraction">
    <pass>
      <state value="lessEqualDepth"/>
      <vs entry="TranslucencyVS"/>
      <ps entry="RefractionPS"/>
    </pass>
  </technique>
  
  
  <shader>
    <![CDATA[
   
float4 LightingPS(TranslucencyVSOut vsOut) : SV_TARGET
{
#ifdef MAT_OPACITYMASK_TEX
  float opacityMask = GetOpacityMask(vsOut.tex.xy);
  clip(opacityMask - 0.1f);
#endif
  
  Material mat = GetMeterial
    (
    #ifdef MAT_UV_COORD
        vsOut.tex,
    #endif
        vsOut.normalW
    #ifdef MAT_NORMAL_TEX
        , vsOut.tangent
    #endif
    );
  
  float3 color = ComputeLigting(mat, vsOut);
    
  return float4(color, 1.0f);
}
   
float4 LightingEmbientPS(TranslucencyVSOut vsOut) : SV_TARGET
{
#ifdef MAT_OPACITYMASK_TEX
  float opacityMask = GetOpacityMask(vsOut.tex.xy);
  clip(opacityMask - 0.1f);
#endif

  Material mat = GetMeterial
    (
    #ifdef MAT_UV_COORD
        vsOut.tex,
    #endif
        vsOut.normalW
    #ifdef MAT_NORMAL_TEX
        , vsOut.tangent
    #endif
    );
  float3 diffColor = mat.baseColor - mat.baseColor * mat.metallic;

  float embient = 1.0f;
  float3 color = diffColor * embient * mat.opacity;
  
  return float4(color, 1.0f);
}
    
    ]]>
  </shader>

  <variable type='BlendState' name='accumBlend'>
    <state name="blendRTDesc" index="0">
      <state name="blendEnable" value="true"/>
      <state name="srcBlend" value="ONE"/>
      <state name="dstBlend" value="ONE"/>
      <state name="dstBlendAlpha" value="ZERO"/>
    </state>
  </variable>

  <technique name="Lighting">
    <pass>
      <state value="lessEqualDepth"/>
      <state value="accumBlend"/>
      <vs entry="TranslucencyVS"/>
      <ps entry="LightingPS"/>
    </pass>
  </technique>

  <technique name="LightingEmbient">
    <pass>
      <state value="lessEqualDepth"/>
      <state value="accumBlend"/>
      <vs entry="TranslucencyVS"/>
      <ps entry="LightingEmbientPS"/>
    </pass>
  </technique>
  
</effect>
