<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>

  <variable type="Texture2D" name="lowResDepthTex"/>
  <variable type="Texture2D" name="highResDepthTex"/>
  <variable type="Texture2D" name="upSamplingInTex"/>

  <variable type="cbuffer" name="cb_bilateralUpSampling">
    <variable type="float" name="depthDiffScale"/>
  </variable>

  <shader>
    <![CDATA[

void GetBilateralUpSamplingCoords(float2 centerPosS, out float2 samplePosS[4], out float4 bilinearWeights)
{
  float2 lowResPosLU = ceil( (centerPosS - 0.5f) * 0.5f ) - 0.5f;
  bilinearWeights.xy = frac(centerPosS * 0.5f);
  bilinearWeights.zw = 1.0f - bilinearWeights.xy;
  bilinearWeights = bilinearWeights.xzxz * bilinearWeights.yyww;
  
  samplePosS[0] = float2(lowResPosLU);
  samplePosS[1] = float2(lowResPosLU) + float2(1, 0);
  samplePosS[2] = float2(lowResPosLU) + float2(0, 1);
  samplePosS[3] = float2(lowResPosLU) + float2(1, 1);
}

float4 BilateralUpSamplingPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float4 bilinearWeights;
  float2 samplesPos[4];
  GetBilateralUpSamplingCoords(vsOut.pos.xy, samplesPos, bilinearWeights);

  static const float epison = 0.001f;
  
  float centerDepth = highResDepthTex.Load(int3(vsOut.pos.xy, 0)).x;
  
  float4 valueSum = 0.0f;
  float weightSum = 0.0f;
  [unroll] for(int i = 0; i < 4; ++i)
  {
    float4 sampleValue = upSamplingInTex.Load(int3(samplesPos[i], 0));
    float sampleDepth = lowResDepthTex.Load(int3(samplesPos[i], 0)).x;
    float depthDiffW = 1.0f / (epison + abs(sampleDepth - centerDepth) * depthDiffScale);
    
    float sampleWeight = bilinearWeights[i] * depthDiffW;
    
    valueSum += sampleValue * sampleWeight;
    weightSum += sampleWeight;
  }
  
  valueSum /= weightSum;
  
  return valueSum;
}
    
    ]]>
  </shader>

  <technique name="BilateralUpSampling">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="BilateralUpSamplingPS"/>
    </pass>
  </technique>
  
</effect>
