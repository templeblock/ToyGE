<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>
  <include name="Util.xml"/>
  
  <variable type="Texture2D" name="sceneTex"/>
  <variable type="Texture2D" name="linearDepthTex"/>

  <shader>
    <![CDATA[
    
float4 SetupPS(PostProcessVSOut vsOut) : SV_TARGET
{
    float4 color = sceneTex.SampleLevel(samplerPoint, vsOut.tex, 0);
    float depth = linearDepthTex.SampleLevel(samplerPoint, vsOut.tex, 0).x;
  
    if(depth <= 0.99f)
      color = 0.0f;
    
    return color;
}
    
    ]]>
  </shader>

  <technique name='Setup'>
    <pass>
      <state value='disableDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='SetupPS'/>
    </pass>
  </technique>
  

  
  <variable type="Texture2D" name="radialBlurInTex"/>
  
  <variable type="cbuffer" name="cb_raidalBlur">
    <variable type="float2" name="lightPosUV"/>
    <variable type="float" name="density"/>
    <variable type="float" name="intensity"/>
    <variable type="float" name="decay"/>
  </variable>
  
  <shader>
    <![CDATA[

#define NUM_SAMPLES 12
  
float4 RadialBlurPS(PostProcessVSOut vsOut) : SV_TARGET
{
  //float density = 0.8f;
  //float weight = 0.7f;
  //float decay = 0.9f;
  
  float2 uvCenter = vsOut.tex;
  
  float centerToLightUVLen = length(uvCenter - lightPosUV);
  
  float2 uvStep = (lightPosUV - uvCenter) * density / NUM_SAMPLES;
  
  float dither = InterleavedGradientNoise(vsOut.pos.xy, 0.5f);
  dither = dither + 0.5f;
  
  float2 sampleUV = uvCenter + dither * uvStep;
  float sampleWeight = 1.0f;
  
  float4 colorAccum = radialBlurInTex.SampleLevel(samplerLinearClamp, sampleUV, 0);
  
  for(int i = 0; i < NUM_SAMPLES; ++i)
  {
    sampleUV += uvStep;
  
    float4 sampleColor = radialBlurInTex.SampleLevel(samplerLinearClamp, sampleUV, 0);
    
    colorAccum += sampleColor * sampleWeight;
    
    sampleWeight *= decay;
  }
  
  colorAccum /= NUM_SAMPLES;
  
  float2 lightPosH = lightPosUV * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f);
  float centerLen = sqrt(max(1e-4, dot(lightPosH, lightPosH)));
  float borderDecay = 1.0f - saturate( (centerLen - 0.0f) / 1.0f );
  
  colorAccum *= borderDecay;
  
  return float4(colorAccum.xyz * intensity, 1.0f);
}
    
    ]]>
  </shader>

  <variable type='BlendState' name='accumBlend'>
    <state name='blendRTDesc' index='0'>
      <state name='blendEnable' value='true'/>
      <state name='srcBlend' value='SRC_ALPHA'/>
      <state name='dstBlend' value='ONE'/>
      <state name='blendOP' value='ADD'/>
    </state>
  </variable>

  <technique name='RadialBlur'>
    <pass>
      <state value='disableDepth'/>
      <!--<state value='accumBlend'/>-->
      <vs entry='PostProcessVS'/>
      <ps entry='RadialBlurPS'/>
    </pass>
  </technique>


  <variable type='cbuffer' name='cb_blurVL'>
    <variable type='float4' name='texSize'/>
  </variable>

  <variable type='Texture2D' name='volumetricLightTex'/>

  <shader>
    <![CDATA[
  
float4 BlurVolumetricLightPS(PostProcessVSOut vsOut) : SV_TARGET
{
    float4 centerColor = volumetricLightTex.SampleLevel(samplerLinear, vsOut.tex, 0);
    
    float4 colorSum = 0.0f;
    
    float2 dir = lightPosUV - vsOut.tex;
    float len = length(dir);
    if(len <= 1e-4)
        return centerColor;
        
    dir /= len;
    
    [unroll] for(int i = -1; i <= 1; ++i)
    {
        if( i == 0 )
            continue;
        
        colorSum += volumetricLightTex.SampleLevel(samplerLinear, vsOut.tex + i * dir * texSize.z * 2.0f, 0);
    }
    
    colorSum /= 3;
    
    return colorSum;
}
  
    ]]>
  </shader>
  
  <technique name='BlurVolumetricLight'>
    <pass>
      <state value='disableDepth'/>
      <state value='accumBlend'/>
      <vs entry='PostProcessVS'/>
      <ps entry='BlurVolumetricLightPS'/>
    </pass>
  </technique>
  
</effect>
