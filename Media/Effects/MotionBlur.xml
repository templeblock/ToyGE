<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>
  
  <variable type="cbuffer" name="cb_initVelocityMap">
    <variable type="float" name="velocityScale"/>
    <variable type="float3" name="_pad_veloctyMap"/>
  </variable>

  <variable type="Texture2D" name="velocityTex"/>

  <shader>
    <![CDATA[
    
#ifndef MAX_VELOCTYLENGTH
#define MAX_VELOCTYLENGTH 20
#endif

#ifndef MB_NUMSAMPLES
#define MB_NUMSAMPLES 20
#endif

float2 InitVelocityMapPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 rawVelocity = velocityTex.Load(int3(vsOut.pos.xy, 0)).xy;
  float2 velocity = rawVelocity * velocityScale;
  float len = length(velocity);
  velocity = velocity / (0.0001f + len) * max(0.5f, min(len, MAX_VELOCTYLENGTH));
  return velocity;
}
    
    ]]>
  </shader>

  <technique name="InitVelocityMap">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="InitVelocityMapPS"/>
    </pass>
  </technique>

  
  <variable type="cbuffer" name="cb_tileMax">
    <variable type="float2" name="texelSize"/>
    <variable type="float2" name="_pad_tileMax"/>
  </variable>
  
  <shader>
    <![CDATA[
    
float2 TileMax(PostProcessVSOut vsOut, float2 dir)
{
  float2 tileStart = (int2(vsOut.pos.xy) * dir * MAX_VELOCTYLENGTH + 0.5f + (vsOut.pos.xy - 0.5f) * (1.0f - dir)) * texelSize;
  
  float2 maxVel = 0.0f;
  float maxVelLen = 0.0f;
  [unroll] for(int i = 0; i < MAX_VELOCTYLENGTH; ++i)
  {
    float2 uv = tileStart + i * dir * texelSize;
    float2 vel = velocityTex.SampleLevel(samplerPointClamp, uv, 0).xy;
    float len = length(vel);
    if(len > maxVelLen)
    {
      maxVel = vel;
      maxVelLen = len;
    }
  }
  
  return maxVel;
}

float2 TileMaxPS_X(PostProcessVSOut vsOut) : SV_TARGET
{
  return TileMax(vsOut, float2(1.0f, 0.0f));
}

float2 TileMaxPS_Y(PostProcessVSOut vsOut) : SV_TARGET
{
  return TileMax(vsOut, float2(0.0f, 1.0f));
}
    
    ]]>
  </shader>

  <technique name="TileMaxX">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="TileMaxPS_X"/>
    </pass>
  </technique>

  <technique name="TileMaxY">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="TileMaxPS_Y"/>
    </pass>
  </technique>


  <variable type="Texture2D" name="tileMaxTex"/>

  <shader>
    <![CDATA[
    
float2 NeighborMaxPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 maxVel = 0.0f;
  float maxVelLen = 0.0f;
  for(int x = -1; x <= 1; ++x)
  {
    for(int y = -1; y <= 1; ++y)
    {
      float2 uv = vsOut.tex.xy + float2(x, y) * texelSize;
      float2 vel = tileMaxTex.SampleLevel(samplerPointClamp, uv, 0).xy;
      float len = length(vel);
      if(len > maxVelLen)
      {
        maxVel = vel;
        maxVelLen = len;
      }
    }
  }
  
  return maxVel;
}
    
    ]]>
  </shader>

  <technique name="NeighborMax">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="NeighborMaxPS"/>
    </pass>
  </technique>


  <variable type="Texture2D" name="sceneTex"/>
  <variable type="Texture2D" name="linearDepthTex"/>
  <variable type="Texture2D" name="neighborMaxTex"/>

  <variable type="cbuffer" name="cb_blur">
    <variable type="uint" name="frameCount"/>
    <variable type="float3" name="_pad_blur"/>
  </variable>

  <shader>
    <![CDATA[
    
float Random(float scale, float2 pos)
{
  float magic = 3571.0;
  float2 rand = (1.0 / 4320.0) * pos + float2(0.25, 0);
  rand = frac( dot(rand * rand, magic) );
  rand = frac( dot(rand * rand, magic) );
  return -scale + 2.0 * scale * rand.x;
}

float CheckBoardDither(float scale, float2 pos)
{
  float2 mod = float2(uint2(pos) & 1);
  float dither = (-scale + 2.0f * scale * mod.x) * (-1.0f + 2.0f * mod.y) + 0.5 * scale * (-1.0 + 2.0 * (frameCount & 1));
  return dither;
}

float2 DepthCmp(float centerDepth, float sampleDepth, float depthScale)
{
  return saturate((centerDepth - sampleDepth) * float2(depthScale, -depthScale) + 0.5);
}

float4 SpreadCmp(float offsetLen, float2 spreadLen, float lenScale)
{
  //return saturate(spreadLen * spreadScale - offsetLen + 1.0f);
  float2 spreadLenScaled = spreadLen * lenScale;
  
  return saturate(1.0 - offsetLen.xxxx * rcp(spreadLenScaled.xyxy) + float4(0, 0, 0.95f, 0.95f));
}

float SampleWeight(
  float centerDepth,
  float sampleDepth,
  float depthScale,
  float centerSpreadLen,
  float sampleSpreadLen,
  float offsetLen,
  float lenScale,
  float2 dirWeight)
{
  float2 depthCmp = DepthCmp(centerDepth, sampleDepth, depthScale);
  float4 spreadCmp = SpreadCmp(offsetLen, float2(sampleSpreadLen, centerSpreadLen), lenScale);
  //float simBlur = Cylinder(offsetLen, centerSpreadLen) * Cylinder(offsetLen, sampleSpreadLen) * max(dirWeight.x, dirWeight.y) * 2.0f;
  return saturate( dot(depthCmp, spreadCmp.xy * dirWeight) + spreadCmp.z * spreadCmp.w * max(dirWeight.x, dirWeight.y) * 2.0f );
}
    
float Cone(float xyLen, float vLen)
{
  return saturate(vLen / xyLen);
}

float Cylinder(float xyLen, float vLen)
{
  return saturate(1.0 - smoothstep(0.95f * vLen, 1.05f * vLen, xyLen));
}

float SoftDepthCompare(float z0, float z1, float soft)
{
  return saturate((z0 - z1) / soft);
}
    
float4 MotionBlurPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 tileDither = float2(Random(1.0f, vsOut.pos.xy), Random(1.0f, vsOut.pos.xy * 2.0));

  float2 vMax = neighborMaxTex.Load(int3((vsOut.pos.xy + tileDither) / MAX_VELOCTYLENGTH, 0)).xy;
  
  float3 color_c = sceneTex.SampleLevel(samplerPointClamp, vsOut.tex.xy, 0).xyz;
  float vMaxLen = max(0.5, length(vMax));
  if(vMaxLen <= 0.5f + 0.001f)
    return float4(color_c, 1.0f);
  
  float z_c = linearDepthTex.SampleLevel(samplerPointClamp, vsOut.tex.xy, 0).x;
  float2 v_c = velocityTex.SampleLevel(samplerPointClamp, vsOut.tex.xy, 0).xy;
  float vLen_c = max(0.5, length(v_c));
  
  float weightSum = 1.0f / (0.001f + vLen_c);
  float3 colorSum = color_c * weightSum;
    
  float sampleDither = CheckBoardDither(0.25, vsOut.pos.xy);
  
  [unroll] for(int i = 0; i <= MB_NUMSAMPLES; ++i)
  {
    if(i == MB_NUMSAMPLES / 2)
      continue;
      
    float t = lerp(-1.0f, 1.0f, float(i + sampleDither) / float(MB_NUMSAMPLES));
    float2 xy = vsOut.pos.xy + vMax * t; //floor(vsOut.pos.xy + i * sampleStep + dither) + 0.5f;
    float2 uv = xy * texelSize;
    float z_i = linearDepthTex.SampleLevel(samplerPointClamp, uv, 0).x;
    
    float2 v_i = velocityTex.SampleLevel(samplerPointClamp, uv, 0).xy;
    
    float vLen_i = max(0.5, length(v_i));
    
    float offsetLen = length(xy - vsOut.pos.xy);
    
    /*
    float weight = 
        depthCmp0 * Cone(xyLen, vLen_i)
      + depthCmp1 * Cone(xyLen, vLen_c)
      + Cylinder(xyLen, vLen_i) * Cylinder(xyLen, vLen_c) * 2.0f;
    */
    float weight = SampleWeight(z_c, z_i, 100, vLen_c, vLen_i, offsetLen, 1.0, 1.0);
    
    float3 color = sceneTex.SampleLevel(samplerPointClamp, uv, 0).xyz;
    colorSum += weight * color;
    weightSum += weight;
  }
  
  colorSum /= weightSum;
  
  return float4(colorSum, 1.0f);
}

    ]]>
  </shader>


  <shader>
    <![CDATA[

float4 MotionBlur2PS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 tileDitherPos = vsOut.pos.xy * (0.5 + 0.5 * (frameCount & 1));
  float2 tileDither = float2(Random(1.0f, tileDitherPos), Random(1.0f, tileDitherPos * 2.0));

  float2 vMax = neighborMaxTex.Load(int3((vsOut.pos.xy + tileDither) / MAX_VELOCTYLENGTH, 0)).xy;
  
  float3 color_c = sceneTex.SampleLevel(samplerPointClamp, vsOut.tex.xy, 0).xyz;
  float vMaxLen = max(0.5, length(vMax));
  if(vMaxLen <= 0.5f + 0.001f)
    return float4(color_c, 1.0f);
    
  float2 dirMax = vMax / (vMaxLen + 0.0001f);
  float2 dirMaxT = float2(-dirMax.y, dirMax.x);
  float2 v_c = velocityTex.SampleLevel(samplerPointClamp, vsOut.tex.xy, 0).xy;
  if(dot(dirMaxT, v_c) < 0)
    dirMaxT = -dirMaxT;
  float vLen_c = max(0.5, length(v_c));
  float2 dir_c = v_c / (vLen_c + 0.0001f);
  float2 sampleDir1 = normalize( lerp( dirMaxT, dir_c, saturate((vLen_c - 0.5f) / 1.5f) ) );
  float2 sampleVec1 = sampleDir1 * vMaxLen;
  float2 sampleVec0 = vMax;
  
  float z_c = linearDepthTex.SampleLevel(samplerPointClamp, vsOut.tex.xy, 0).x;
  
  float weightSum = MB_NUMSAMPLES / (MB_NUMSAMPLES * vLen_c + 0.001f);
  float3 colorSum = weightSum * color_c;
  
  float sampleDither = CheckBoardDither(0.25, vsOut.pos.xy);
  
  [unroll] for(uint i = 0; i <= MB_NUMSAMPLES; ++i)
  {
    if(i == MB_NUMSAMPLES / 2)
      continue;
      
    float t = lerp(-1.0f, 1.0f, float(i + sampleDither) / float(MB_NUMSAMPLES));
    float2 v = (i & 1) ? sampleVec0 : sampleVec1;
    float2 sampleDir = normalize(v);
    float2 xy = vsOut.pos.xy + t * v;// + sampleDir * sampleDither;
    float2 uv = xy * texelSize;
    float z_i = linearDepthTex.SampleLevel(samplerPointClamp, uv, 0).x;

    float2 v_i = velocityTex.SampleLevel(samplerPointClamp, uv, 0).xy;
    
    float vLen_i = max(0.5, length(v_i));
    
    float offsetLen = length(xy - vsOut.pos.xy);
    
    float w_0 = abs(dot(v_i / (vLen_i), sampleDir)); //Outer
    float w_1 = abs(dot(dir_c, sampleDir)); //Inner

    float weight = SampleWeight(z_c, z_i, 100, vLen_c, vLen_i, offsetLen, 1.0, float2(w_0, w_1));
    
    float3 color = sceneTex.SampleLevel(samplerPointClamp, uv, 0).xyz;
    colorSum += weight * color;
    weightSum += weight;
  }
  
  colorSum /= weightSum;
  
  return float4(colorSum, 1.0f);
}
    
    ]]>
  </shader>

  
  <shader>
    <![CDATA[

float4 MotionBlur3PS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 tileDitherPos = vsOut.pos.xy * (0.5 + 0.5 * (frameCount & 1));
  float2 tileDither = float2(Random(1.0f, tileDitherPos), Random(1.0f, tileDitherPos * 2.0));

  float2 vMax = neighborMaxTex.Load(int3((vsOut.pos.xy + tileDither) / MAX_VELOCTYLENGTH, 0)).xy;
  
  float3 color_c = sceneTex.SampleLevel(samplerPointClamp, vsOut.tex.xy, 0).xyz;
  float vMaxLen = length(vMax);
  if(vMaxLen <= 0.5f + 0.001f)
    return float4(color_c, 1.0f);
    
  float2 dirMax = vMax / (vMaxLen + 0.0001f);
  float2 dirMaxT = float2(-dirMax.y, dirMax.x);
  float2 v_c = velocityTex.SampleLevel(samplerPointClamp, vsOut.tex.xy, 0).xy;
  if(dot(dirMaxT, v_c) < 0)
    dirMaxT = -dirMaxT;
  float vLen_c = max(0.5, length(v_c));
  float2 dir_c = v_c / (vLen_c + 0.0001f);
  float2 sampleDir1 = normalize( lerp( dirMaxT, dir_c, saturate((vLen_c - 0.5f) / 1.5f) ) );
  float2 sampleVec1 = sampleDir1 * vMaxLen;
  float2 sampleVec0 = vMax;
  
  float z_c = linearDepthTex.SampleLevel(samplerPointClamp, vsOut.tex.xy, 0).x;

  float weightSum = 0.0f;
  float3 colorSum = 0.0f;
  
  float sampleDither = CheckBoardDither(0.25f, vsOut.pos.xy);
  
  [unroll] for(uint i = 0; i <= MB_NUMSAMPLES; ++i)
  {
    if(i == MB_NUMSAMPLES / 2)
      continue;
      
    float t = lerp(-1.0f, 1.0f, float(i + sampleDither) / float(MB_NUMSAMPLES));
    float2 v = (i & 1) ? sampleVec0 : sampleVec1;
    float2 sampleDir = normalize(v);
    float2 xy = vsOut.pos.xy + t * v;
    float2 uv = xy * texelSize;
    float z_i = linearDepthTex.SampleLevel(samplerPointClamp, uv, 0).x;
    
    float2 v_i = velocityTex.SampleLevel(samplerPointClamp, uv, 0).xy;
    
    float vLen_i = max(0.5, length(v_i));
    
    float xyLen = length(xy - vsOut.pos.xy);
    
    float w_0 = (abs(dot(v_i / (vLen_i), sampleDir)));
    float w_1 = (abs(dot(dir_c, sampleDir)));
      
    float weight = SampleWeight(z_c, z_i, 200, vLen_c, vLen_i, xyLen, 1.0, float2(w_0, w_1));
    weight = saturate(weight * 10.0f);
    
    float3 color = sceneTex.SampleLevel(samplerPointClamp, uv, 0).xyz;
    colorSum += weight * color;
    weightSum += weight;
  }
  
  weightSum /= MB_NUMSAMPLES;
  colorSum /= MB_NUMSAMPLES;
  colorSum = colorSum + saturate(1.0 - weightSum) * color_c;
  
  return float4(colorSum, 1.0f);
}
    
    ]]>
  </shader>

  <technique name="MotionBlur">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="MotionBlur3PS"/>
    </pass>
  </technique>
  
</effect>