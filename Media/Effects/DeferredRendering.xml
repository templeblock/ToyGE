<?xml version='1.0'?>

<effect>
  <include name='Lighting.xml'/>
  <include name='Shadow.xml'/>
  <include name='PostProcess.xml'/>
  <include name='CommonState.xml'/>

<!--GBuffer-->
  
  <variable type='cbuffer' name='cb_gbufferVS_perFrame'>
    <variable type='float4x4' name='viewProj'/>
  </variable>

  <variable type='cbuffer' name='cb_gbufferVS_perObj'>
    <variable type='float4x4' name='world'/>
  </variable>
  
  <variable type='cbuffer' name='cb_gbufferPS_perObj'>
    <variable type='float4' name='meterialParams_0'/> <!--baseColor[xyz] roughness[w]-->
    <variable type='float4' name='meterialParams_1'/> <!--metallic[x]-->
    <variable type='int4' name='opacityConfig'/>
  </variable>

  <variable type='Texture2D' name='baseColorTex' />
  <variable type='Texture2D' name='roughnessTex' />
  <variable type='Texture2D' name='normalTex' />
  <variable type='Texture2D' name='normalFittingTex' />
  <variable type='Texture2D' name='opacityMaskTex' />
  
  <shader>
    <![CDATA[
    
#if defined(BASECOLOR_TEX) || defined(ROUGHNESS_TEX) || defined(NORMAL_TEX)
#define UV_COORD
#endif
    
struct GBufferVSIn
{
	float3 pos : POSITION;
#ifdef UV_COORD
	float3 tex : TEXCOORD;
#endif
	float3 normal : NORMAL;
#ifdef NORMAL_TEX
	float3 tangent : TANGENT;
#endif
};

struct GBufferVSOut
{
	float4 posH : SV_POSITION;
#ifdef UV_COORD
	float3 tex : TEXCOORD;
#endif
	float3 normal : NORMAL;
#ifdef NORMAL_TEX
	float3 tangent : TANGENT;
#endif
};

GBufferVSOut GBufferVS(GBufferVSIn vsIn)
{
	GBufferVSOut vsOut;

	float4x4 worldViewProj = mul( world, viewProj );
  
	vsOut.posH = mul(float4(vsIn.pos.xyz, 1.0f), worldViewProj);
  
#ifdef UV_COORD
	vsOut.tex = vsIn.tex;
#endif

	vsOut.normal = mul(float4(vsIn.normal.xyz, 0.0f), world).xyz;
#ifdef NORMAL_TEX
	vsOut.tangent = mul(float4(vsIn.tangent.xyz, 0.0f), world).xyz;
#endif

	return vsOut;
}

struct GBufferPSOut
{
  float4 gbuffer0 : SV_TARGET0;
  float4 gbuffer1 : SV_TARGET1;
};

void CompressNormal(inout half3 normal)
{
  float3 absNormal = abs(normal);
  float maxAbs = max(max(absNormal.x, absNormal.y), absNormal.z);
  float2 texCoord = absNormal.z < maxAbs ? (absNormal.y < maxAbs ? absNormal.yz : absNormal.xz) : absNormal.xy;
  texCoord = texCoord.x < texCoord.y ? texCoord.yx : texCoord.xy;
  texCoord.y /= texCoord.x;
  
  normal /= maxAbs;
  float scale = normalFittingTex.SampleLevel(samPoint, texCoord, 0).a;
  normal *= scale;
  normal = normal * 0.5h + 0.5h;
}

GBufferPSOut GBufferPS(GBufferVSOut vsOut)
{
  GBufferPSOut psOut;
  
#ifdef UV_COORD
  if(opacityConfig.x == 1)
  {
    float opacity = opacityMaskTex.Sample(samLinear, vsOut.tex.xy).x;
    clip(opacity - 0.1f);
  }
#endif

float3 baseColor;
#ifdef BASECOLOR_TEX
  baseColor = diffTex.Sample(samplerLinear, vsOut.tex.xy).xyz;
  baseColor = fGammaCorrectIn(baseColor);
#else
  baseColor = materialParams_0.xyz;
#endif
  psOut.gbuffer0.xyz = baseColor;
  
  float roughness;
#ifdef ROUGHNESS_TEX
  roughness = roughnessTex.Sample(samLinear, vsOut.tex.xy).x;
#else
  roughness = materialParams.w;
#endif

  float metallic;
  metallic = materialParams.x;
  psOut.gbuffer1.w = metallic;
  
  float3 normal;
#ifdef NORMAL_TEX
  float3 N = normalize(vsOut.normal);
	float3 T = normalize(vsOut.tangent);
	float3 B = cross(N, T);
	float3x3 texToWorld = float3x3(T, B, N);
	float3 normalSam = normalTex.Sample(samLinear, vsOut.tex.xy).xyz;
	normalSam = normalSam * 2.0f - 1.0f;
	normalSam = normalize(normalSam);
	normal = mul(normalSam, texToWorld);
#else
  normal = normalize(vsOut.normal);
#endif
  //normal = normal * 0.5f + 0.5f;
  CompressNormal(normal);
  psOut.gbuffer1.xyz = normal;

	return psOut;
}
    ]]>
  </shader>
  
  <technique name='GBuffer'>
    <pass>
      <state value='dssStencilWrite'/>
      <vs entry='GBufferVS'/>
      <ps entry='GBufferPS'/>
    </pass>
  </technique>
  <technique name='GBuffer_BaseColorTex'>
    <pass>
      <macro name='BASECOLOR_TEX'/>
      <state value='dssStencilWrite'/>
      <vs entry='GBufferVS'/>
      <ps entry='GBufferPS'/>
    </pass>
  </technique>
  <technique name='GBuffer_RoughnessTex'>
    <pass>
      <macro name='ROUGHNESS_TEX'/>
      <state value='dssStencilWrite'/>
      <vs entry='GBufferVS'/>
      <ps entry='GBufferPS'/>
    </pass>
  </technique>
  <technique name='GBuffer_NormalTex'>
    <pass>
      <macro name='NORMAL_TEX'/>
      <state value='dssStencilWrite'/>
      <vs entry='GBufferVS'/>
      <ps entry='GBufferPS'/>
    </pass>
  </technique>
  <technique name='GBuffer_NormalBaseColorTex'>
    <pass>
      <macro name='NORMAL_TEX'/>
      <macro name='BASECOLOR_TEX'/>
      <state value='dssStencilWrite'/>
      <vs entry='GBufferVS'/>
      <ps entry='GBufferPS'/>
    </pass>
  </technique>
  <technique name='GBuffer_NormalRoughnessTex'>
    <pass>
      <macro name='NORMAL_TEX'/>
      <macro name='ROUGHNESS_TEX'/>
      <state value='dssStencilWrite'/>
      <vs entry='GBufferVS'/>
      <ps entry='GBufferPS'/>
    </pass>
  </technique>
  <technique name='GBuffer_DiffSpecTex'>
    <pass>
      <macro name='DIFF_TEX'/>
      <macro name='ROUGHNESS_TEX'/>
      <state value='dssStencilWrite'/>
      <vs entry='GBufferVS'/>
      <ps entry='GBufferPS'/>
    </pass>
  </technique>
  <technique name='GBuffer_NormalDiffSpecTex'>
    <pass>
      <macro name='DIFF_TEX'/>
      <macro name='NORMAL_TEX'/>
      <macro name='ROUGHNESS_TEX'/>
      <state value='dssStencilWrite'/>
      <vs entry='GBufferVS'/>
      <ps entry='GBufferPS'/>
    </pass>
  </technique>


<!--DepthLinear-->

  <variable type='Texture2D' format='float' name='rawDepthTex'/>

  <variable type='cbuffer' name='cb_depthLinear'>
    <variable type='float4' name='linearParam'/>
  </variable>
  
  <shader>
    <![CDATA[
    
float DepthLinearPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float z = rawDepthTex.SampleLevel(samPoint, vsOut.tex, 0);
  return ((linearParam.y / (z - linearParam.x)) - linearParam.z) / (linearParam.w - linearParam.z) ;
}
    
    ]]>
  </shader>

  <technique name='DepthLinear'>
    <pass>
      <state value='disableDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='DepthLinearPS'/>
    </pass>
  </technique>
  
  
<!--Lighting-->

  <variable type='Texture2D' format='float' name='depthLinearTex'/>
  <variable type='Texture2D' name='gbuffer0'/>
  <variable type='Texture2D' name='gbuffer1'/>
  <variable type='Texture2D' name='gbuffer2'/>
  <variable type='Texture2D' name='accumTex0'/>
  <variable type='Texture2D' name='accumTex1'/>
  
  <variable type='cbuffer' name='cb_lightingPS_perFrame'>
    <variable type='float4x4' name='proj'/>
    <variable type='float4x4' name='invView'/>
    <variable type='float4' name='camNearFar'/>
    <variable type='float4' name='viewPos'/>
    <variable type='float4' name='lightPos'/>
    <variable type='float4' name='lightDir'/>
    <variable type='float4' name='lightRadiance'/>
    <variable type='float4' name='decreaseFac'/>
  </variable>

 
  <shader>
    <![CDATA[

struct LightingPSOut
{
  float4 color0 : SV_TARGET0;
  float4 color1 : SV_TARGET1;
};

LightingPSOut LightingPS(PostProcessVSOut vsOut)
{
  LightingPSOut psOut;
  
  float4 gbuf0 = gbuffer0.SampleLevel(samPoint, vsOut.tex, 0.0f);
  float4 gbuf2 = gbuffer2.SampleLevel(samPoint, vsOut.tex, 0.0f);
  float depthVNorm = depthLinearTex.SampleLevel(samPoint, vsOut.tex, 0.0f);
  
  //Calculate posV, posW
  float2 screenSize = gbuffer0.Length.xy;
  float2 posH_xy = (vsOut.pos.xy - 0.5) / screenSize * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f);
  float near = camNearFar.x;
  float far = camNearFar.y;
  float posV_z = depthVNorm * (far - near) + near;
  float posV_x = posH_xy.x * posV_z / proj[0][0];
  float posV_y = posH_xy.y * posV_z / proj[1][1];
  float4 posV = float4(posV_x, posV_y, posV_z, 1.0f);
  float4 posW = mul(posV, invView);

  //normal
  float3 normal = normalize(gbuf0.xyz * 2.0f - 1.0f);


//Calculate Shadow
  float shadow = 1.0f;
if(shadowConfig.x == 1)
{
#ifdef LIGHT_POINT
    float3 dir = posW.xyz - lightPos.xyz;
    float len = length(dir); 
    float reciever = len / pointMaxDist.x;
    dir /= len;
    
    [branch] switch(shadowConfig.y)
    {
      case VSM:
      {
        shadow = CalcShadow_VSM(shadowTexCubeArray, 0, dir, reciever);
        break;
      } 
      
      case ESM:
      {
        shadow = CalcShadow_ESM(shadowTexCubeArray, 0, dir, reciever, pointMaxDist.x);
        break;
      }
      
      /*
      case SAVSM:
      {
        shadow = CalcShadow_SAVSM_FP(shadowTexCubeArray, 0, dir, reciever, savsmFilterSize.x);
        break;
      }
      
      case PCSS_SAVSM:
      {
        float dBlocker = SearchBlocker_SAVSM_FP(shadowTexCubeArray, 0, dir, reciever, (0.1f / pointMaxDist.x));
        float penumbraSize = GetPenumbraSize(reciever, dBlocker, 5.0f);
        shadow = CalcShadow_SAVSM_FP(shadowTexCubeArray, 0, dir, reciever, penumbraSize * 2.0f + 2.0f);
        break;
      }
      */
    }
#endif

#ifdef LIGHT_SPOT
    float4 posLV = mul(posW, spotView);
    float reciever = (posLV.z - spotNearFar.x) / (spotNearFar.y - spotNearFar.x);
    //float3 dir = posW.xyz - lightPos.xyz;
    //float len = length(dir); 
    //float reciever = len / spotMaxDist.x;
    
    float4 posLH = mul(posLV, spotProj);
    posLH /= posLH.w;
    float2 shadowUV = float2(posLH.x * 0.5f + 0.5f, posLH.y * -0.5f + 0.5f);
    
    [branch] switch(shadowConfig.y)
    {
      case VSM:
      {
        shadow = CalcShadow_VSM(shadowTexArray, 0, shadowUV, reciever);
        break;
      }
      
      case ESM:
      {
        shadow = CalcShadow_ESM(shadowTexArray, 0, shadowUV, reciever, spotNearFar.y - spotNearFar.x);
        break;
      }
      
      case SAVSM:
      {
        shadow = CalcShadow_SAVSM_FP(shadowTexArray, 0, shadowUV, reciever, savsmFilterSize.x);
        break;
      }
      
      case PCSS_SAVSM:
      {
        float dBlocker = SearchBlocker_SAVSM_FP(shadowTexArray, 0, shadowUV, reciever, (0.1f / (spotNearFar.y - spotNearFar.x)));
        float penumbraSize = GetPenumbraSize(reciever, dBlocker, 5.0f);
        shadow = CalcShadow_SAVSM_FP(shadowTexArray, 0, shadowUV, reciever, penumbraSize * 1.5f + 3.0f);
        break;
      }
    }
#endif

#ifdef LIGHT_DIRECTIONAL

    uint splitIndex = PSSMFindSplitIndex(posV.z);
    /*
    const float4 splitColorMap[] = {
									float4(1.0f, 0.0f, 0.0f, 1.0f),
									float4(0.0f, 1.0f, 0.0f, 1.0f),
									float4(0.0f, 0.0f, 1.0f, 1.0f),
									float4(1.0f, 1.0f, 0.0f, 1.0f)
								};
    psOut.color0 = splitColorMap[splitIndex];
    */
  
    float4x4 viewCrop = pssmViewCrop[splitIndex];
    float4 posLH = mul(posW, viewCrop);
    posLH /= posLH.w;
    float2 shadowUV = float2(posLH.x * 0.5f + 0.5f, posLH.y * -0.5f + 0.5f);
    float reciever = posLH.z;   
    
    [branch] switch(shadowConfig.y)
    {
      case VSM:
      {
        shadow = CalcShadow_VSM(shadowTexArray, splitIndex, shadowUV, reciever);
        break;
      }
      
      case ESM:
      {
        shadow = CalcShadow_ESM(shadowTexArray, splitIndex, shadowUV, reciever, pssmLightMaxDist[splitIndex].x);
        break;
      }
      
      /*
      case SAVSM:
      {
        shadow = CalcShadow_SAVSM_FP(shadowTexArray, splitIndex, shadowUV, reciever, savsmFilterSize.x);
        break;
      }
      
      case PCSS_SAVSM:
      {
        float dBlocker = SearchBlocker_SAVSM_FP(shadowTexArray, splitIndex, shadowUV, reciever, (0.1f / spotMaxDist.x));
        float penumbraSize = GetPenumbraSize(reciever, dBlocker, 5.0f);
        shadow = CalcShadow_SAVSM_FP(shadowTexArray, splitIndex, shadowUV, reciever, penumbraSize * 2.0f + 2.0f);
        break;
      }
      */
    }
#endif

}

  float3 n = normal;
  float3 l = normalize(lightPos.xyz - posW.xyz);
	float3 v = normalize(viewPos.xyz - posW.xyz);
	float3 h = normalize(l + v);
  
  float3 light_in = 0.0f;
#ifdef LIGHT_POINT
	light_in = lightRadiance.xyz * CalcPointLight(posW.xyz, normal, lightPos.xyz);
#endif
#ifdef LIGHT_SPOT
	light_in = lightRadiance.xyz * CalcSpotLight(posW.xyz, normal, lightPos.xyz, lightDir.xyz, decreaseFac.x);
#endif
#ifdef LIGHT_DIRECTIONAL
	light_in = lightRadiance.xyz * CalcDirectionalLight(normal, lightDir.xyz);
#endif
  
  light_in *= shadow;
  
  psOut.color0 = 0.0f;
  psOut.color0.xyz = light_in / PI;

	float3 c_spec = gbuf2.x;
	float shininess = gbuf2.w * 255;
  float roughness = saturate(pow(2.0f / (shininess + 2.0f), 0.25f));
  
  //float D = NDF_BlinnPhong(n, h, roughness);
  float D = NDF_GGX(n, h, roughness);
  float3 F = Freshnel_Schlick(v, h, c_spec);
  float G = G_Implicit(n, l, v);
  psOut.color1 = 0.0f;
  psOut.color1.xyz = light_in * D * F * G / ( 4.0f * max(EPISON, dot(n, l)) * max(EPISON, dot(n, v)) );
  
  psOut.color0 = psOut.color0 + accumTex0.SampleLevel(samPoint, vsOut.tex, 0.0f);
  psOut.color1 = psOut.color1 + accumTex1.SampleLevel(samPoint, vsOut.tex, 0.0f);
  
  return psOut;
}

    ]]>
  </shader>

  <technique name='Lighting_Point'>
    <pass>
      <macro name='LIGHT_POINT'/>
      <state value='disableDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='LightingPS'/>
    </pass>
  </technique>

  <technique name='Lighting_Spot'>
    <pass>
      <macro name='LIGHT_SPOT'/>
      <state value='disableDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='LightingPS'/>
    </pass>
  </technique>

  <technique name='Lighting_Directional'>
    <pass>
      <macro name='LIGHT_DIRECTIONAL'/>
      <state value='disableDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='LightingPS'/>
    </pass>
  </technique>


<!--Shading-->
  
  <variable type='Texture2D' name='lightingTex0'/>
  <variable type='Texture2D' name='lightingTex1'/>
  <variable type='Texture2D' name='aoTex'/>
  <variable type='cbuffer' name='cb_shadingPS_perFrame'>
    <variable type='int4' name='screenSize'/>
  </variable>
  
  <shader>
    <![CDATA[
struct ShadingVSIn
{
	float3 pos : POSITION;
#ifdef SHADING_DIFF_TEX
	float3 tex : TEXCOORD;
#endif
};

struct ShadingVSOut
{
	float4 pos : SV_POSITION;
#ifdef SHADING_DIFF_TEX
	float3 tex : TEXCOORD;
#endif
};

ShadingVSOut ShadingVS(ShadingVSIn vsIn)
{
	ShadingVSOut vsOut;

	float4x4 worldViewProj = mul( world, viewProj );
	vsOut.pos = mul(float4(vsIn.pos.xyz, 1.0f), worldViewProj);
#ifdef SHADING_DIFF_TEX
	vsOut.tex = vsIn.tex;
#endif

	return vsOut;
}

float4 ShadingPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float4 light0 = lightingTex0.SampleLevel(samPoint, vsOut.tex, 0.0f);
  float4 light1 = lightingTex1.SampleLevel(samPoint, vsOut.tex, 0.0f);
  float4 gbuf1 = gbuffer1.SampleLevel(samPoint, vsOut.tex, 0.0f);
  
  float4 diff = gbuf1;

  float4 embient = 0.001f;
  
  float ao = 1.0f;
#ifdef SHADING_AO
  ao = aoTex.SampleLevel(samLinear, vsOut.tex, 0).x;
#endif
  
  float4 color = diff * (light0 + embient * ao) + light1;
  
  return float4(color.xyz, 1.0f);
}
    ]]>
  </shader>

  <variable type='DepthStencilState' name='lessEqualDepth'>
    <state name='depthFunc' value='LESS_EQUAL'/>
  </variable>
  
  <variable type='DepthStencilState' name='dssStencilMask'>
    <state name='depthEnable' value='false'/>
    <state name='stencilEnable' value='true'/>
    <state name='frontFace'>
      <state name='stencilFunc' value='EQUAL'/>
    </state>
    <state name='stencilRef' value='1'/>
  </variable>
  
  <technique name='Shading'>
    <pass>
      <state value='lessEqualDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='ShadingPS'/>
    </pass>
  </technique>

  <!--<technique name='Shading_DiffTex'>
    <pass>
      <macro name='SHADING_DIFF_TEX'/>
      <state value='lessEqualDepth'/>
      <vs entry='ShadingVS'/>
      <ps entry='ShadingPS'/>
    </pass>
  </technique>-->

  <technique name='Shading_AO'>
    <pass>
      <macro name='SHADING_AO'/>
      <state value='lessEqualDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='ShadingPS'/>
    </pass>
  </technique>

  <!--<technique name='Shading_DiffTex_AO'>
    <pass>
      <macro name='SHADING_AO'/>
      <macro name='SHADING_DIFF_TEX'/>
      <state value='lessEqualDepth'/>
      <vs entry='ShadingVS'/>
      <ps entry='ShadingPS'/>
    </pass>
  </technique>-->
  
</effect>