<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="PostProcess.xml"/>
  <include name="Util.xml"/>
  <include name="Material.xml"/>
  <include name="View.xml"/>
  <include name="Lighting.xml"/>

  <variable type="Texture2D" name="linearDepthTex"/>
  <variable type="Texture2D" name="gbuffer0"/>
  <variable type="Texture2D" name="gbuffer1"/>
  <variable type="Texture2D" name="lighting0"/>
  <variable type="Texture2D" name="lighting1"/>
  <variable type="Texture2D" name="diffuseTex"/>

  <variable type='DepthStencilState' name='stencilEqual2'>
    <state name='depthEnable' value='false'/>
    <state name='stencilEnable' value='true'/>
    <state name='frontFace'>
      <state name='stencilFunc' value='EQUAL'/>
    </state>
    <state name='stencilRef' value='2'/>
  </variable>

  <shader>
    <![CDATA[
    
float3 ComputeDiffusePS(PostProcessVSOut vsOut) : SV_TARGET
{
    Material mat = GbufferToMaterial(
        gbuffer0.SampleLevel(samplerPoint, vsOut.tex.xy, 0),
        gbuffer1.SampleLevel(samplerPoint, vsOut.tex.xy, 0)
        );
    
    float3 diffColor = mat.baseColor - mat.metallic * mat.baseColor;
    
    //float3 diffColor = float3(0.48f, 0.41f, 0.28f);
    
    float3 ambient = 0.1f;
    
    float3 diffuse = diffColor * lighting0.SampleLevel(samplerPoint, vsOut.tex.xy, 0).xyz + mat.baseColor * ambient;
    
    return diffuse;
}
    
    ]]>
  </shader>

  <technique name="ComputeDiffuse">
    <pass>
      <state value="stencilEqual2"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ComputeDiffusePS"/>
    </pass>
  </technique>
  
  
  <shader>
    <![CDATA[
   
#define BLUR_RADIUS 4

float3 Gauss(float3 var, float3 d2)
{
    return 1.0f / (2.0 * PI * var) * exp(- d2 * 0.5 / var);
}
   
float3 SubsurfaceScatteingBlur(PostProcessVSOut vsOut, float2 dir)
{
    float radiusW = 0.02f;
    float3 varNear = float3(0.25f, 0.08f, 0.02f);
    //varNear = varNear * varNear;
    float3 varFar = float3(1.0f, 0.3f, 0.05f);
    //varFar = varFar * varFar;
    
    float w = 0.6f;
    float3 varMax = max(varNear, varFar);
    
    float centerLinearZ = linearDepthTex.SampleLevel(samplerPoint, vsOut.tex.xy, 0).x;
    float centerDepth = centerLinearZ * (cameraNearFar.y - cameraNearFar.x) + cameraNearFar.x;
    
    float radiusH = radiusW * proj[0][0] / centerDepth;
    
    float2 stepH = radiusH / BLUR_RADIUS * 0.5 * dir;
    
    float2 stepUV = stepH * 0.5;
    float2 sampleUV = vsOut.tex.xy - BLUR_RADIUS * stepUV;
    
    float2 centerPosH = vsOut.pos.xy * viewSize.zw * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f);
    float2 samplePosH = centerPosH - BLUR_RADIUS * stepH;
    
    float3 centerPosV = LinearDepthToViewPos(centerLinearZ, cameraNearFar, centerPosH, proj);
    
    //float3 sigmaMax = max(sigmaNear, sigmaFar);
    
    float3 color = 0.0f;
    float3 wSum = 0.0f;
    
    for(int i = -BLUR_RADIUS; i <= BLUR_RADIUS; ++i)
    {
        float sampleLinearZ = linearDepthTex.SampleLevel(samplerLinearClamp, sampleUV, 0).x;
        float3 samplePoV = LinearDepthToViewPos(sampleLinearZ, cameraNearFar, samplePosH, proj);
        float3 sampleDiffuse = diffuseTex.SampleLevel(samplerLinearClamp, sampleUV, 0).xyz;
        
        float3 falloff = float3(1.0f, 0.37f, 0.3f);
    
        float3 d = abs(samplePoV - centerPosV) / radiusW * 3.0f;
        d /= falloff;
        
        float3 d2_z = d.z / (falloff);
        d2_z *= d2_z;
        float3 dxy2 = sqrt(d.x * d.x + d.y * d.y) / falloff;
        dxy2 *= dxy2;
        
        float3 wi = exp(- d2_z / (2.0 * varMax) ) * ( w * Gauss(varNear, dxy2) + (1.0 - w) * Gauss(varFar, dxy2) );
        wSum += wi;
        
        color += sampleDiffuse * wi;
        
        samplePosH += stepH;
        sampleUV += stepUV;
    }
    
    color /= wSum;
    
#ifdef ADD_SPECULAR
    color += lighting1.SampleLevel(samplerPoint, vsOut.tex.xy, 0).xyz;
#endif
    
    return color;
}


float3 SubsurfaceScatteingBlurXPS(PostProcessVSOut vsOut) : SV_TARGET
{
    return SubsurfaceScatteingBlur(vsOut, float2(1.0f, 0.0f));
}

float3 SubsurfaceScatteingBlurYPS(PostProcessVSOut vsOut) : SV_TARGET
{
    return SubsurfaceScatteingBlur(vsOut, float2(0.0f, 1.0f));
}
    
    ]]>
  </shader>

  <technique name="SubsurfaceScatteingBlurX">
    <pass>
      <state value="stencilEqual2"/>
      <vs entry="PostProcessVS"/>
      <ps entry="SubsurfaceScatteingBlurXPS"/>
    </pass>
  </technique>

  <technique name="SubsurfaceScatteingBlurY">
    <pass>
      <state value="stencilEqual2"/>
      <vs entry="PostProcessVS"/>
      <ps entry="SubsurfaceScatteingBlurYPS"/>
    </pass>
  </technique>


  <shader>
    <![CDATA[
    
float3 TransmittancePS(PostProcessVSOut vsOut) : SV_TARGET
{
    float linearZ = linearDepthTex.SampleLevel(samplerPoint, vsOut.tex.xy, 0).x;
    
    float3 posV = LinearDepthToViewPos(linearZ, cameraNearFar, vsOut.pos.xy, viewSize.xy, proj);
    float3 posW = mul(float4(posV, 1.0f), invView).xyz;
    
    float4 gbuf0 = gbuffer0.SampleLevel(samplerPoint, vsOut.tex.xy, 0);
    float4 gbuf1 = gbuffer1.SampleLevel(samplerPoint, vsOut.tex.xy, 0);
    
    Material mat = GbufferToMaterial(
        gbuffer0.SampleLevel(samplerPoint, vsOut.tex.xy, 0),
        gbuffer1.SampleLevel(samplerPoint, vsOut.tex.xy, 0)
        );
    
    float3 normal = mat.normal;
    
    posW -= normal * 0.005f;
    
    float recieverDepth;
    float shadowDepth = GetShadowDepth(posW, posV.z, recieverDepth);
    
    float d;
    
    float3 transColor = float3(1.0f, 0.3f, 0.05f);
    
#if (LIGHT_TYPE == LIGHT_TYPE_POINT)

    float3 light = lightPos - posW;
    float3 absLight = abs(light);
    
    float3 zDir;
    if(absLight.x == recieverDepth)
        zDir = float3(1.0f, 0.0f, 0.0f) * sign(light.x);
    else if(absLight.y == recieverDepth)
        zDir = float3(0.0f, 1.0f, 0.0f) * sign(light.y);
    else
        zDir = float3(0.0f, 0.0f, 1.0f) * sign(light.z);
        
    light /= max(0.0001f, length(light));
    
    float cosTheta = max(0.0001f, dot(zDir, light));
    
    d = 0.0f;
    
     float3 zAxis = normal;//pos / len;
        float3 yAxis = abs(zAxis.y) < 0.99 ? float3(0.0f, 1.0f, 0.0f) : float3(1.0f, 0.0f, 0.0f);
        float3 xAxis = cross(yAxis, zAxis);
        
        float noise = InterleavedGradientNoise(vsOut.pos.xy, PI);
        float2 sinCos = float2(sin(noise), cos(noise));
        float2x2 rotation = float2x2(
            sinCos.x, sinCos.y,
            -sinCos.y, sinCos.x);
        
        float3 resultColor = 0.0f;
        
        [unroll] for(int i = 0; i < PCF_NUMSAMPLES; ++i)
        {
            float2 sampleOffset = mul(PCFGetSampleOffset(i) * 0.02f, rotation);
            float3 samplePos = posW + sampleOffset.x * xAxis + sampleOffset.y * yAxis;
            
            float t;
            shadowDepth = GetShadowDepth(samplePos, posV.z, t);
            
            d += abs(recieverDepth - shadowDepth) / cosTheta;
            //d = abs(recieverDepth - shadowDepth) / cosTheta * 100.0;
            
            resultColor += transColor * exp(-d * d);
        }
        
        resultColor /= PCF_NUMSAMPLES;
        d /= PCF_NUMSAMPLES;
        
    float dLight = abs(shadowDepth) / cosTheta;
    
    float3 inLight = lightRadiance / dLight / dLight;
    inLight = inLight * saturate(-0.3 + dot(light, -normal)) * mat.baseColor;
    
#elif (LIGHT_TYPE == LIGHT_TYPE_SPOT)
    
    float3 light = lightPos - posW;
    
    light /= max(0.0001f, length(light))
    
    d = abs(recieverDepth - shadowDepth) / ( dot(-lightDir, light) );
    
#elif (LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL)
    
    d = abs(shadowDepth - recieverDepth);
    
#endif

    float radiusW = 0.02f;
    
    //float scale = 8.25 * (1.0 - 0.8) / radiusW;
    
    //d *= scale;
    
    d *= 50.0;
    
    //d = max(d, 0.2f);
    
    float dd = -d * d;
    float3 profile = float3(0.233, 0.455, 0.649) * exp(dd / 0.0064) +
                     float3(0.1,   0.336, 0.344) * exp(dd / 0.0484) +
                     float3(0.118, 0.198, 0.0)   * exp(dd / 0.187)  +
                     float3(0.113, 0.007, 0.007) * exp(dd / 0.567)  +
                     float3(0.358, 0.004, 0.0)   * exp(dd / 1.99)   +
                     float3(0.078, 0.0,   0.0)   * exp(dd / 7.41);

    return profile * inLight;
}
    
    ]]>
  </shader>

  <variable type='BlendState' name='srcOne_dstOne_Add'>
    <state name="blendRTDesc" index="0">
      <state name="blendEnable" value="true"/>
      <state name="srcBlend" value="ONE"/>
      <state name="dstBlend" value="ONE"/>
      <state name="dstBlendAlpha" value="ZERO"/>
    </state>
  </variable>
  
  <technique name="Transmittance">
    <pass>
      <state value="disableDepth"/>
      <state value="srcOne_dstOne_Add"/>
      <vs entry="PostProcessVS"/>
      <ps entry="TransmittancePS"/>
    </pass>
  </technique>
  
</effect>