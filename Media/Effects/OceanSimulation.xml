<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>
  
  <variable type="Texture2D" name="h0Tex"/>
  <variable type="Texture2D" name="omegaTex"/>
  
  <variable type="cbuffer" name="cb_updateSpectrum">
    <variable type="float4" name="elapsedTime"/>
  </variable>
  
  <variable type='SamplerState' name='samPoint'>
    <state name='filter' value='MIN_MAG_MIP_POINT'/>
    <state name='addressU' value='CLAMP'/>
    <state name='addressV' value='CLAMP'/>
  </variable>
  
  <shader>
    <![CDATA[

struct UpdateSpectrumPsOut
{
  float2 ht : SV_TARGET0;
  float4 dk : SV_TARGET1;
};

UpdateSpectrumPsOut UpdateSpectrumPS(PostProcessVSOut vsOut)
{
  UpdateSpectrumPsOut psOut;
  
  float2 texSize = h0Tex.Length.xy;
  float2 texelSize = 1.0f / texSize;
  float2 texCoord_Conj = (texSize - (vsOut.pos.xy - 0.5f)) + 0.5f;
  texCoord_Conj *= texelSize;
  float2 h0 = h0Tex.SampleLevel(samPoint, vsOut.tex, 0).xy;
  float2 h0_Conj = h0Tex.SampleLevel(samPoint, texCoord_Conj, 0).xy;
  
  float omega = omegaTex.SampleLevel(samPoint, vsOut.tex, 0).x;
  float omega_t = omega * elapsedTime.x;
  float cos_omega_t = cos(omega_t);
  float sin_omega_t = sin(omega_t);
  float ht_x = (h0.x + h0_Conj.x) * cos_omega_t + (-h0.y + h0_Conj.y) * sin_omega_t;
  float ht_y = (h0.x - h0_Conj.x) * sin_omega_t + (h0.y + h0_Conj.y) * cos_omega_t;
  psOut.ht = float2(ht_x, ht_y);
  
  float2 k = vsOut.pos.xy - 0.5f - texSize * 0.5f;
  float k_p2 = k.x * k.x + k.y * k.y;
  if(k_p2 > 0.00001f)
    k /= k_p2;
  float2 dx = float2(ht_y * k.x, -ht_x * k.x);
  float2 dy = float2(ht_y * k.y, -ht_x * k.y);
  psOut.dk = float4(dx, dy);
  
  return psOut;
}


    ]]>
  </shader>

  <technique name='UpdateSpectrum'>
    <pass>
      <state value='disableDepth'/>
      <vs entry='PostProcessVS'/>
      <ps entry='UpdateSpectrumPS'/>
    </pass>
  </technique>

</effect>