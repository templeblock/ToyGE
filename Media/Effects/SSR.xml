<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>
  <include name="Util.xml"/>
  <include name="Lighting.xml"/>

  <variable type="Texture2D" format="float" name="depthTex"/>

  <variable type="cbuffer" name="cb_hzb">
    <variable type="float4" name="screenSize"/>
    <variable type="uint" name="mipLevel"/>
  </variable>

  <shader>
    <![CDATA[
    
float HZBBuildPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 uv0 = vsOut.tex.xy + float2(-0.5f, -0.5f) * screenSize.zw;
  float2 uv1 = vsOut.tex.xy + float2( 0.5f, -0.5f) * screenSize.zw;
  float2 uv2 = vsOut.tex.xy + float2(-0.5f,  0.5f) * screenSize.zw;
  float2 uv3 = vsOut.tex.xy + float2( 0.5f,  0.5f) * screenSize.zw;
  
  float z0 = depthTex.SampleLevel(samplerPointClamp, uv0, mipLevel).x;
  float z1 = depthTex.SampleLevel(samplerPointClamp, uv1, mipLevel).x;
  float z2 = depthTex.SampleLevel(samplerPointClamp, uv2, mipLevel).x;
  float z3 = depthTex.SampleLevel(samplerPointClamp, uv3, mipLevel).x;
  
  return min( min(z0, z1), min(z2, z3) );
}
    
    ]]>
  </shader>

  <technique name="HZBBuild">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="HZBBuildPS"/>
    </pass>
  </technique>

  
  <variable type="Texture2D" name="sceneTex"/>
  <variable type="Texture2D" name="gbuffer0"/>
  <variable type="Texture2D" name="gbuffer1"/>

  <variable type="cbuffer" name="cb_ssr">
    <variable type="float4x4" name="view"/>
    <variable type="float4x4" name="proj"/>
    <variable type="float2" name="cameraNearFar"/>
    <variable type="uint" name="frameCount"/>
  </variable>

  <variable type="cbuffer" name="cb_dither">
    <variable type="float4x4" name="dither"/>
  </variable>
  
  <shader>
    <![CDATA[
    
#define NUM_RAYS 8
#define NUM_SAMPLES_PER_RAY 4
    
uint MortonCode( uint x )
{
	//x = (x ^ (x <<  8)) & 0x00ff00ff;
	//x = (x ^ (x <<  4)) & 0x0f0f0f0f;
	x = (x ^ (x <<  2)) & 0x33333333;
	x = (x ^ (x <<  1)) & 0x55555555;
	return x;
}

uint ReverseUIntBits( uint bits )
{
	//bits = ( bits << 16) | ( bits >> 16);
	//bits = ( (bits & 0x00ff00ff) << 8 ) | ( (bits & 0xff00ff00) >> 8 );
	//bits = ( (bits & 0x0f0f0f0f) << 4 ) | ( (bits & 0xf0f0f0f0) >> 4 );
	bits = ( (bits & 0x33333333) << 2 ) | ( (bits & 0xcccccccc) >> 2 );
	bits = ( (bits & 0x55555555) << 1 ) | ( (bits & 0xaaaaaaaa) >> 1 );
	return bits;
}

float4 SampleTexDepth(float4 sampleUV0, float4 sampleUV1, float level)
{
  float z0 = depthTex.SampleLevel(samplerPointClamp, sampleUV0.xy, level).x;
  float z1 = depthTex.SampleLevel(samplerPointClamp, sampleUV0.zw, level).x;
  float z2 = depthTex.SampleLevel(samplerPointClamp, sampleUV1.xy, level).x;
  float z3 = depthTex.SampleLevel(samplerPointClamp, sampleUV1.zw, level).x;
  
  return float4(z0, z1, z2, z3);
}



float3 RandomTraceDir(float3 view, float3 normal, float roughness, float2 screenPos, uint rayIndex, uint2 random)
{
  float3 traceDir;
  //if(bGlossy)
  {
    //uint2 random = ScrambleTEA( uint2( screenPos ) ^ (rayIndex * 177), 3);
    
    //float e0 = frac( float( random.x & 0xffff ) / (1<<16) );
		//float e1 = frac( float( random.y & 0xffff ) / (1<<16) );
    
    
    float2 sample2D = Hammersley2d(rayIndex, NUM_RAYS, random);
    
    float e0 = sample2D.x;
    float e1 = sample2D.y;
    
    e0 += 0.001f;
		e1 += 0.001f;
    
    float3 zAxis = abs(normal.z) < 0.99 ? float3(0.0f, 0.0f, 1.0f) : float3(1.0f, 0.0f, 0.0f);
    float3 yAxis = normal;
    float3 xAxis = normalize( cross(yAxis, zAxis) );
    zAxis = cross(xAxis, yAxis);
    
    float a = roughness * roughness;
    float a2 = a * a;
    
    //Blinn
    float n = 2 / a2 - 2;
		float phi = 2 * PI * e0;
		float cosTheta = pow( e1, 1 / (n + 1) );
		float sinTheta = sqrt( 1 - cosTheta * cosTheta );
    
    float3 h = yAxis * cosTheta + xAxis * sinTheta * sin(phi) + zAxis * sinTheta * cos(phi);
    
    traceDir = reflect(-view, h);
  }
  //else
  //{
    //traceDir = reflect(-view, normal);
  //}
  
  return traceDir;
}


float4 RayTracing(float3 startPos, float3 traceDir, float roughness, int numSamples, float2 screenPos, float3 rayStartH, float3 rayStartUVz, float offset)
{
  //uint2 ditherPos = ((uint2(screenPos) * 177) ^ rayIndex) & 3;
  //uint2 ditherPos = uint2(screenPos) & 3;
  //float offset = dither[ditherPos.x][ditherPos.y];
  
  //[branch] if( traceDir.z < -0.99 )
  //  return 0.0f;
    
  float3 rayStartV = startPos;
  float3 rayEndV = startPos + traceDir;
  
  float4 rayEndH = mul(float4(rayEndV, 1.0f), proj);
  
  rayEndH.xyz /= rayEndH.w;
  
  float stepLenScale = min(1.5 / length(rayEndH.xy - rayStartH.xy), (0.5 * (sign(traceDir.z) + 1) - rayStartH.z) / (rayEndH.z - rayStartH.z));
  //float stepLenScale = 1.5 / length(rayEndH.xy - rayStartH.xy);
  float3 rayStepH = (rayEndH.xyz - rayStartH.xyz) * stepLenScale;
  rayStepH /= float(numSamples + 1);
  
  float3 rayStepUVz = float3(rayStepH.xy * float2(0.5, -0.5), rayStepH.z);
  
  const float depthTolerance = abs( rayStepH.z ) * 1.0;
  
  float lastDepthDiff = abs(rayStepUVz.z);
  float3 hitUVz = 0.0f;
  float hitPos = 0.0f;
  
  float4 samplePos = float4(1, 2, 3, 4) + offset;
  float level = 0.0f;
  
  [unroll] for(int i = 0; i < numSamples; i += 4)
  {
    float4 sampleUV0 = rayStartUVz.xyxy + samplePos.xxyy * rayStepUVz.xyxy;
    float4 sampleUV1 = rayStartUVz.xyxy + samplePos.zzww * rayStepUVz.xyxy;
    float4 sampleRayDepth = ( rayStartUVz.z + samplePos * rayStepUVz.z );
    
    float4 sampleTexDepth = SampleTexDepth(sampleUV0, sampleUV1, level);
    
    float4 depthDiffCur = sampleRayDepth - sampleTexDepth;
    //bool4 hit = abs(-depthDiffCur - depthTolerance) < depthTolerance;
    bool4 hit = abs(depthDiffCur - depthTolerance) < depthTolerance;
    //bool4 hit = depthDiffCur > 0.0f;
    
    [branch] if( any(hit) )
    {
      float4 depthDiffPre = float4(lastDepthDiff, depthDiffCur.xyz);
      //float4 hitPos4 = samplePos + saturate( -depthDiffCur / (depthDiffCur - depthDiffPre) );
      //hitPos4 = hit ? hitPos4 : -FLT_MAX;
      
      //hitPos = max( max(hitPos4.x, hitPos4.y), max(hitPos4.z, hitPos4.w) );
      
      float4 hitPos4 = samplePos - saturate( depthDiffCur / (depthDiffCur - depthDiffPre) );
      hitPos4 = hit ? hitPos4 : FLT_MAX;
      
      hitPos = min( min(hitPos4.x, hitPos4.y), min(hitPos4.z, hitPos4.w) );
      
      //bHit = true;
      hitUVz = rayStartUVz + hitPos * rayStepUVz;
      
      break;
    }
    
    lastDepthDiff = depthDiffCur.w;
    
    samplePos += 4;
    level += 9 * roughness / numSamples;
  }
  
  return float4(hitUVz, hitPos / (numSamples + 1));
}

float3 SampleSceneColor(float4 hitResult)
{
  float3 traceColor = 0.0f;
  //[branch] if(bHit)
  {
    traceColor = sceneTex.SampleLevel(samplerPointClamp, hitResult.xy, 0).rgb;
    
    float2 hitCenterDist = abs( hitResult.xy - 0.5 ) * 2.0;
    hitCenterDist = saturate( hitCenterDist * 5.0 - 4.0 );
    float borderFade = saturate( 1.0 - dot(hitCenterDist, hitCenterDist) );
    
    traceColor *= borderFade;
    
    //traceColor *= roughnessFade;
    
    traceColor *= saturate( 4 - hitResult.w * 4 );
  }
  
  return traceColor;
}

float4 ScreenSpaceReflectionPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float4 gbuf1 = gbuffer1.SampleLevel(samplerPointClamp, vsOut.tex, 0.0f);
  float roughness = gbuf1.w;
  
  float maxRoughness = 0.9f;
  float roughnessFade = 1.0 - saturate(roughness / maxRoughness);
  
  [branch] if(roughnessFade == 0)
    return 0;
  
  float curDepth = depthTex.SampleLevel(samplerPointClamp, vsOut.tex.xy, 0).x;
  float3 curPosV = PespectiveDepthToViewPos(curDepth, vsOut.pos.xy, screenSize.xy, proj);
  
  float4 gbuf0 = gbuffer0.SampleLevel(samplerPointClamp, vsOut.tex, 0.0f);
  
  float3 baseColor = gbuf0.xyz;
  float metallic = gbuf0.w;
  float roughnessAdj = lerp(0.1f, 0.9f, roughness);
  float3 specColor = lerp(0.03f, baseColor, metallic);
  
  float3 curNormalW = DecodeNormal(gbuf1.xyz);//normalize(gbuf1.xyz * 2.0f - 1.0f);
  float3 curNormalV = mul(float4(curNormalW, 0.0f), view).xyz;
  
  float3 viewDirV = normalize(-curPosV);
  
  uint frameRandom = (frameCount % 4) * 1551;
  //uint frameRandom = 0;
  
  float3 traceColor = 0.0f;
  
  float3 rayStartH = float3(vsOut.tex.xy * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f), curDepth);
  float3 rayStartUVz = float3(vsOut.tex.xy, curDepth);
  
#if NUM_RAYS > 1
  
  uint Morton = MortonCode( uint(vsOut.pos.x) & 3 ) | ( MortonCode( uint(vsOut.pos.y) & 3 ) * 2 );
	uint PixelIndex = ReverseUIntBits( Morton );
  
  uint2 Random = ScrambleTEA( uint2( vsOut.pos.xy ), 3 );
  
  [unroll] for(int i = 0; i < NUM_RAYS; ++i)
  {
    uint Offset = ( PixelIndex + ReverseUIntBits( uint(i) * 117 ) ) & 15;
	  float StepOffset = Offset / 15.0;
		StepOffset -= 0.9;
  
    float3 traceDirV = RandomTraceDir(viewDirV, curNormalV, roughnessAdj, vsOut.pos.xy, uint(i), Random);
    
    if(traceDirV.z < -0.99)
      continue;
    
    float4 traceResult = RayTracing(curPosV, traceDirV, roughnessFade, NUM_SAMPLES_PER_RAY, vsOut.pos.xy, rayStartH, rayStartUVz, StepOffset);
    
    [branch] if(traceResult.w != 0.0)
    {
      float3 traceColorRay = SampleSceneColor(traceResult);
      traceColorRay /= 1 + GetIlluminance(traceColorRay);
      
      traceColor += traceColorRay;
    }
    
  }
  traceColor /= float(NUM_RAYS);
  traceColor /= 1 - GetIlluminance(traceColor);
  
#else
  
  {
    float3 traceDirV = reflect(-viewDirV, curNormalV);
    if(tranceDirV.z < -0.99)
      traceColor = 0.0f
    else
    {
    float4 traceResult = RayTracing(curPosV, traceDirV, roughness, roughnessFade, NUM_SAMPLES_PER_RAY, vsOut.pos.xy, rayStartH, rayStartUVz, uint(i) * 117);
    
    [branch] if(traceResult.w != 0.0)
    {
      traceColor += SampleSceneColor(traceResult);
    }
    }
  }
  
#endif
  
  traceColor *= roughnessFade;
  
  float3 n = curNormalV;
  float3 v = viewDirV;
  
  float3 F = Fresnel_Schlick(v, n, specColor);
  float n_dot_v = max(1e-5, dot(n, v));
  
  float3 reflectColor = traceColor * F * 5.0f;
  
  return float4(reflectColor, 1.0f);
}
    
    ]]>
  </shader>

  <variable type='DepthStencilState' name='noDepth_stencilGreater0'>
    <state name='depthEnable' value='false'/>
    <state name='depthWriteMask' value='ZERO'/>
    <state name='stencilEnable' value='true'/>
    <state name='frontFace'>
      <state name='stencilFunc' value='NOT_EQUAL'/>
    </state>
    <state name='backFace'>
      <state name='stencilFunc' value='NOT_EQUAL'/>
    </state>
    <state name='stencilRef' value='0'/>
  </variable>

  <variable type='BlendState' name='srcOne_dstOne_Add'>
    <state name="blendRTDesc" index="0">
      <state name="blendEnable" value="true"/>
      <state name="srcBlend" value="ONE"/>
      <state name="dstBlend" value="ONE"/>
      <state name="dstBlendAlpha" value="ZERO"/>
    </state>
  </variable>

  <technique name="ScreenSpaceReflection">
    <pass>
      <state value="noDepth_stencilGreater0"/>
      <state value="srcOne_dstOne_Add"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ScreenSpaceReflectionPS"/>
    </pass>
  </technique>
  
</effect>