<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="VSMUtil.xml"/>

  <variable type='cbuffer' name='cb_savsm'>
    <variable type='float4' name='savsmFilterSize'/>
    <variable type='float' name='vsmBias'/>
    <variable type='float' name='vsmReduceBlending'/>
    <variable type='float2' name='_pad_vsm'/>
  </variable>

  <variable type='SamplerState' name='samSATPoint'>
    <state name='filter' value='MIN_MAG_MIP_POINT'/>
    <state name='addressU' value='CLAMP'/>
    <state name='addressV' value='CLAMP'/>
  </variable>
  
  <shader>
    <![CDATA[

/*
VSM
*/

float CalcShadow_VSM(float2 moments, float reciever)
{
  return ChebyshevUpperBound(moments, reciever, vsmBias * 0.01f, vsmReduceBlending);
}

float CalcShadow_VSM(Texture2DArray tex, uint arrayIndex, float2 uv, float reciever)
{
  float2 moments = tex.SampleLevel(samplerLinearClamp, float3(uv, arrayIndex), 0).xy;
  return CalcShadow_VSM(moments, reciever); 
}

float CalcShadow_VSM(TextureCubeArray tex, uint arrayIndex, float3 dir, float reciever)
{
  float2 moments = tex.SampleLevel(samplerLinearClamp, float4(dir, arrayIndex), 0).xy;
  return CalcShadow_VSM(moments, reciever);
}

float GetShadowDepth_VSM(Texture2DArray tex, uint arrayIndex, float2 uv)
{
    float2 moments = tex.SampleLevel(samplerLinearClamp, float3(uv, arrayIndex), 0).xy;
    return moments.x;
}

float GetShadowDepth_VSM(TextureCubeArray tex, uint arrayIndex, float3 dir)
{
    float2 moments = tex.SampleLevel(samplerLinearClamp, float4(dir, arrayIndex), 0).xy;
    return moments.x;
}

/*
EVSM
*/

float CalcShadow_EVSM2(float2 moments, float reciever)
{
  float recieverWarp = WarpDepth2(reciever);
  
  float depthScale = vsmBias * 0.01f * EVSM_POS_EXPONENT * recieverWarp;
  float minVariance = depthScale * depthScale;
  
  float shadow = ChebyshevUpperBound(moments.xy, recieverWarp.x, minVariance, vsmReduceBlending);
  
  return shadow;
}

float CalcShadow_EVSM2(Texture2DArray tex, uint arrayIndex, float2 uv, float reciever)
{
  float shadow = 1.0f;
  
  //if( !any( abs(uv - 0.5f) > 0.5f ) )
  //{
  
  float2 moments = tex.SampleLevel(samplerLinearClamp, float3(uv, arrayIndex), 0).xy;
  shadow = CalcShadow_EVSM2(moments, reciever);
  //}
  
  return shadow;
}

float CalcShadow_EVSM2(TextureCubeArray tex, uint arrayIndex, float3 dir, float reciever)
{
  float2 moments = tex.SampleLevel(samplerLinearClamp, float4(dir, arrayIndex), 0).xy;
  return CalcShadow_EVSM2(moments, reciever);
}

float GetShadowDepth_EVSM2(Texture2DArray tex, uint arrayIndex, float2 uv)
{
  float2 moments = tex.SampleLevel(samplerLinearClamp, float3(uv, arrayIndex), 0).xy;
  return log(moments.x) / EVSM_POS_EXPONENT;
}

float GetShadowDepth_EVSM2(TextureCubeArray tex, uint arrayIndex, float3 dir)
{
  float2 moments = tex.SampleLevel(samplerLinearClamp, float4(dir, arrayIndex), 0).xy;
  return log(moments.x) / EVSM_POS_EXPONENT;
}


float CalcShadow_EVSM4(float4 moments, float reciever)
{
  float2 recieverWarp = WarpDepth4(reciever);
    
  float2 depthScale = vsmBias * 0.01f * float2(EVSM_POS_EXPONENT, EVSM_NEG_EXPONENT) * recieverWarp;
  float2 minVariance = depthScale * depthScale;
    
  float shadowPos = ChebyshevUpperBound(moments.xy, recieverWarp.x, minVariance.x, vsmReduceBlending);
  float shadowNeg = ChebyshevUpperBound(moments.zw, recieverWarp.y, minVariance.y, vsmReduceBlending);
  float shadow = min(shadowPos, shadowNeg);
  
  return shadow;
}

float CalcShadow_EVSM4(Texture2DArray tex, uint arrayIndex, float2 uv, float reciever)
{
  float4 moments = tex.SampleLevel(samplerLinearClamp, float3(uv, arrayIndex), 0);
  return CalcShadow_EVSM4(moments, reciever);
}

float CalcShadow_EVSM4(TextureCubeArray tex, uint arrayIndex, float3 dir, float reciever)
{
  float4 moments = tex.SampleLevel(samplerLinearClamp, float4(dir, arrayIndex), 0);
  return CalcShadow_EVSM4(moments, reciever);
}

float GetShadowDepth_EVSM4(Texture2DArray tex, uint arrayIndex, float2 uv)
{
  float4 moments = tex.SampleLevel(samplerLinearClamp, float3(uv, arrayIndex), 0);
  return log(moments.x) / EVSM_POS_EXPONENT;
}

float GetShadowDepth_EVSM4(TextureCubeArray tex, uint arrayIndex, float3 dir)
{
  float4 moments = tex.SampleLevel(samplerLinearClamp, float4(dir, arrayIndex), 0);
  return log(moments.x) / EVSM_POS_EXPONENT;
}

/*
SAVSM
*/

float2 GetMomentsFP4(float4 v)
{
  int distriPrecision = 8;
  float2 ret = RecombinePrecision(v, 1 << distriPrecision);
  
  //unbias
  ret += 0.5f;
  
  return ret;
}

/*
Cube Sample Util
*/
uint GetCubeMapSampleIndex(float3 dir)
{
/*
  float2 texSize;
  float elementCnt;
  tex.GetDimensions(texSize.x, texSize.y, elementCnt);
*/
  
  float3 absDir = abs(dir);
  float maxAbs = max(absDir.x, max(absDir.y, absDir.z));
  uint index = 0;
  if(maxAbs == absDir.x)
  {
    if(dir.x > 0)
      index = 0;
    else
      index = 1;
  }
  else if(maxAbs == absDir.y)
  {
    if(dir.y > 0)
      index = 2;
    else
      index = 3;
  }
  else
  {
    if(dir.z > 0)
      index = 4;
    else
      index = 5;
  }
  return index;
}

void GetTexelUVMap(uint texIndex,
                   out float3 uMap, out float3 vMap)
{
  static const float3 uOffsetMap[] = 
  {
    float3(0, 0, -1), //+x
    float3(0, 0,  1), //-x
    float3(-1, 0, 0), //+y
    float3( 1, 0, 0), //-y
    float3( 1, 0, 0), //+z
    float3(-1, 0, 0)  //-z
  };
  
  static const float3 vOffsetMap[] = 
  {
    float3(0, -1, 0), //+x
    float3(0, -1, 0), //-x
    float3(0, 0, -1), //+y
    float3(0, 0, -1), //-y
    float3(0, -1, 0), //+z
    float3(0, -1, 0)  //-z
  };
  
  uMap = uOffsetMap[texIndex];
  vMap = vOffsetMap[texIndex];
}

float3 GetDirMap(uint texIndex)
{
  static const float3 dirMap[] = 
  {
    float3( 1, 0, 0),
    float3(-1, 0, 0),
    float3(0,  1, 0),
    float3(0, -1, 0),
    float3(0, 0,  1),
    float3(0, 0, -1)
  };
  return dirMap[texIndex];
}

float2 GetTexelUV(float3 dir, uint texIndex)
{
  float3 dirMap = GetDirMap(texIndex);
  dir /= dot(dir, dirMap);
  float3 uMap;
  float3 vMap;
  GetTexelUVMap(texIndex,
                uMap, vMap);
                
  float2 uv;
  uv.x = dot(dir, uMap) * 0.5f + 0.5f;
  uv.y = dot(dir, vMap) * 0.5f + 0.5f;
  
  return uv;
}

float3 GetTexelDir(float2 uv, float2 texSize, uint texIndex)
{
  float3 dirMap = GetDirMap(texIndex);
  float3 uMap;
  float3 vMap;
  GetTexelUVMap(texIndex,
                uMap, vMap);
  float3 uDir = (uv.x - 0.5f) * 2 * uMap;
  float3 vDir = (uv.y - 0.5f) * 2 * vMap;
  return dirMap + uDir + vDir;
}

uint GetTexIndex_Left(uint texIndex, inout float4 uvQuad)
{
  static const uint indexMap[] = 
  {
    4, 5,
    0, 1,
    1, 0
  };
  
  float4 uvMap[] = 
  {
    uvQuad,
    uvQuad,
    float4(uvQuad.y, 1.0f - uvQuad.z, uvQuad.w, 1.0f - uvQuad.x),
    float4(1.0f - uvQuad.w, uvQuad.x, 1.0f - uvQuad.y, uvQuad.z),
    uvQuad,
    uvQuad
  };
  uvQuad = uvMap[texIndex];
  return indexMap[texIndex];
}

uint GetTexIndex_Right(uint texIndex, inout float4 uvQuad)
{
  static const uint indexMap[] = 
  {
    5, 4,
    1, 0,
    0, 1
  };
  
  float4 uvMap[] = 
  {
    uvQuad,
    uvQuad,
    float4(1.0f - uvQuad.w, uvQuad.x, 1.0f - uvQuad.y, uvQuad.z),
    float4(uvQuad.w, 1.0f - uvQuad.z, uvQuad.w, 1.0f - uvQuad.x),
    uvQuad,
    uvQuad
  };
  uvQuad = uvMap[texIndex];
  return indexMap[texIndex];
}

uint GetTexIndex_Up(uint texIndex, inout float4 uvQuad)
{
  static const uint indexMap[] = 
  {
    2, 2,
    4, 4,
    2, 2
  };
  
  float4 uvMap[] = 
  {
    float4(1.0f - uvQuad.w, uvQuad.x, 1.0f - uvQuad.y, uvQuad.z),
    float4(uvQuad.y, 1.0f - uvQuad.z, uvQuad.w, 1.0f - uvQuad.x),
    float4(1.0f - uvQuad.z, 1.0f - uvQuad.w, 1.0f - uvQuad.x, 1.0f - uvQuad.y),
    uvQuad,
    float4(1.0f - uvQuad.z, 1.0f - uvQuad.w, 1.0f - uvQuad.x, 1.0f - uvQuad.y),
    uvQuad
  };
  uvQuad = uvMap[texIndex];
  return indexMap[texIndex];
}

uint GetTexIndex_Down(uint texIndex, inout float4 uvQuad)
{
  static const uint indexMap[] = 
  {
    3, 3,
    5, 5,
    3, 3
  };
  
  float4 uvMap[] = 
  {
    float4(1.0f - uvQuad.w, uvQuad.x, 1.0f - uvQuad.y, uvQuad.z),
    float4(uvQuad.y, 1.0f - uvQuad.z, uvQuad.w, 1.0f - uvQuad.x),
    uvQuad,
    float4(1.0f - uvQuad.z, 1.0f - uvQuad.w, 1.0f - uvQuad.x, 1.0f - uvQuad.y),
    uvQuad,
    float4(1.0f - uvQuad.z, 1.0f - uvQuad.w, 1.0f - uvQuad.x, 1.0f - uvQuad.y)
  };
  uvQuad = uvMap[texIndex];
  return indexMap[texIndex];
}


/*
Sample SAT Bilinear Util
*/
float4 GetFilterQuad(float2 uv, float2 dx, float2 dy, float2 texSize,
                   float2 minFilterSize, float2 maxFilterSize)
{
  float2 texelSize = 1.0f / texSize;
  float2 deriFilterSize = 2 * (abs(dx) + abs(dy)) * texSize;
  deriFilterSize = min(maxFilterSize, deriFilterSize);
  
  float2 filterSize = round( max(minFilterSize, deriFilterSize) );
  float2 uvLU = uv - (filterSize - 1.0f) * 0.5f * texelSize;
  return float4(filterSize, uvLU);
}

void GetBilUVAndWeights(float2 uvLU, float2 texSize, 
                        out float2 uvLUBil, out float4 bilWeights)
{
  float2 texelSize = 1.0f / texSize;
  float2 texelCoords = uvLU * texSize;
  
  bilWeights.xy = frac(texelCoords + 0.5f);
  bilWeights.zw = 1.0f - bilWeights.xy;
  bilWeights = bilWeights.zxzx * bilWeights.wwyy;
  
  uvLUBil = (floor(texelCoords - 0.5f) + 0.5f) * texelSize;
}

/*
Sample SAT
*/

float4 SampleSATSumFP(Texture2DArray tex, uint arrayIndex, float4 uvQuad)
{
  float2 texSize;
  float numElements;
  tex.GetDimensions(texSize.x, texSize.y, numElements);
  float2 texelSize = 1.0f / texSize;
  float4 lu = tex.SampleLevel(samSATPoint, float3(uvQuad.xy, arrayIndex), 0);
  float4 ru = tex.SampleLevel(samSATPoint, float3(uvQuad.zy, arrayIndex), 0);
  float4 ld = tex.SampleLevel(samSATPoint, float3(uvQuad.xw, arrayIndex), 0);
  float4 rd = tex.SampleLevel(samSATPoint, float3(uvQuad.zw, arrayIndex), 0);
  
  return (lu - ru - ld + rd);
}

void SampleSATBilFP(Texture2DArray tex, uint arrayIndex, float4 uvQuad,
                      out float4 bil0, out float4 bil1, out float4 bil2, out float4 bil3)
{
  float2 texSize;
  float numElements;
  tex.GetDimensions(texSize.x, texSize.y, numElements);
  float2 texelSize = 1.0f / texSize;
  
  float4 uvQuadAjust = uvQuad - texelSize.xyxy;
  //sample four quads
  bil0 = SampleSATSumFP(tex, arrayIndex, uvQuadAjust + (float2(0, 0) * texelSize).xyxy);
  bil1 = SampleSATSumFP(tex, arrayIndex, uvQuadAjust + (float2(1, 0) * texelSize).xyxy);
  bil2 = SampleSATSumFP(tex, arrayIndex, uvQuadAjust + (float2(0, 1) * texelSize).xyxy);
  bil3 = SampleSATSumFP(tex, arrayIndex, uvQuadAjust + (float2(1, 1) * texelSize).xyxy);
  
  //avg
  float2 size = (uvQuad.zw - uvQuad.xy) * texSize;
  float invArea = 1.0f / (size.x * size.y);
  bil0 *= invArea;
  bil1 *= invArea;
  bil2 *= invArea;
  bil3 *= invArea;
}

/*
Sample SAT Cube
*/
float4 SampleSATSumFP(TextureCubeArray tex, uint arrayIndex, uint texIndex, float4 uvQuad)
{
  float2 texSize;
  float elementCnt;
  tex.GetDimensions(texSize.x, texSize.y, elementCnt);
  float2 texelSize = 1.0f / texSize;
  
  float4 lu = tex.SampleLevel(samSATPoint, float4(GetTexelDir(uvQuad.xy, texSize, texIndex), arrayIndex), 0);
  float4 ru = tex.SampleLevel(samSATPoint, float4(GetTexelDir(uvQuad.zy, texSize, texIndex), arrayIndex), 0);
  float4 ld = tex.SampleLevel(samSATPoint, float4(GetTexelDir(uvQuad.xw, texSize, texIndex), arrayIndex), 0);
  float4 rd = tex.SampleLevel(samSATPoint, float4(GetTexelDir(uvQuad.zw, texSize, texIndex), arrayIndex), 0);
  
  return (lu - ru - ld + rd);
}

float4 SampleSATSumFP_CubeV(TextureCubeArray tex, uint arrayIndex, uint texIndex, float4 uvQuad)
{
  float2 texSize;
  float elementCnt;
  tex.GetDimensions(texSize.x, texSize.y, elementCnt);
  float2 texelSize = 1.0f / texSize;
  
  float l = uvQuad.x;
  float r = uvQuad.z;
  float u = uvQuad.y;
  float d = uvQuad.w;
  
  float4 ret = 0.0f;
  [branch] if(d > 1.0f)
  {
    float upD = 1.0f - texelSize.y * 0.5f;
    float4 uvQuadU = float4(l, u, r, upD);
    float4 uSum = SampleSATSumFP(tex, arrayIndex, texIndex, uvQuadU);
    float downU = texelSize.y * 0.5f;
    float4 uvQuadD = float4(l, texelSize.y * 0.5f, r, d - 1.0f);
    uint downTexIndex = GetTexIndex_Down(texIndex, uvQuadD);
    float4 dSum = SampleSATSumFP(tex, arrayIndex, downTexIndex, uvQuadD);
    
    float uWeights = (upD - u) / (d - u);
    ret = uSum + dSum;
  }
  else if(u < 0.0f)
  {
    float downU = texelSize.y * 0.5f;
    float4 uvQuadD = float4(l, downU, r, d);
    float4 dSum = SampleSATSumFP(tex, arrayIndex, texIndex, uvQuadD);
    float4 uvQuadU = float4(l, u + 1.0f, r, 1.0f - texelSize.y * 0.5f);
    uint upTexIndex = GetTexIndex_Up(texIndex, uvQuadU);
    float4 uSum = SampleSATSumFP(tex, arrayIndex, upTexIndex, uvQuadU);
    
    float dWeights = (d - downU) / (d - u);
    ret = uSum + dSum;
  }
  else
  {
    ret = SampleSATSumFP(tex, arrayIndex, texIndex, uvQuad);
  }
  
  return ret;
}

float4 SampleSATSumFP_CubeU(TextureCubeArray tex, uint arrayIndex, uint texIndex, float4 uvQuad)
{
  float2 texSize;
  float elementCnt;
  tex.GetDimensions(texSize.x, texSize.y, elementCnt);
  float2 texelSize = 1.0f / texSize;
  
  float l = uvQuad.x;
  float r = uvQuad.z;
  float u = uvQuad.y;
  float d = uvQuad.w;
  
  float4 ret = 0.0f;
  [branch] if(r > 1.0f)
  {
    float leftR = 1.0f - texelSize.x * 0.5f;
    float4 uvQuadL = float4(l, u, leftR, d);
    float4 lSum = SampleSATSumFP_CubeV(tex, arrayIndex, texIndex, uvQuadL);
    float4 uvQuadR = float4(texelSize.x * 0.5f, u, r - 1.0f, d);
    uint rightTexIndex = GetTexIndex_Right(texIndex, uvQuadR);
    float4 rSum = SampleSATSumFP_CubeV(tex, arrayIndex, rightTexIndex, uvQuadR);
    
    ret = lSum + rSum;
  }
  else if(l < 0.0f)
  {
    float rightL = texelSize.x * 0.5f;
    float4 uvQuadR = float4(rightL, u, r, d);
    float4 rSum = SampleSATSumFP_CubeV(tex, arrayIndex, texIndex, uvQuadR);
    float4 uvQuadL = float4(l + 1.0f, u, 1.0f - texelSize.x * 0.5f, d);
    uint leftTexIndex = GetTexIndex_Left(texIndex, uvQuadL);
    float4 lSum = SampleSATSumFP_CubeV(tex, arrayIndex, leftTexIndex, uvQuadL);
    
    ret = lSum + rSum;
  }
  else
  {
    ret = SampleSATSumFP_CubeV(tex, arrayIndex, texIndex, uvQuad);
  }
  
  return ret;
}

void SampleSATBilFP(TextureCubeArray tex, uint arrayIndex, uint texIndex, float4 uvQuad,
                      out float4 bil0, out float4 bil1, out float4 bil2, out float4 bil3)
{
  float2 texSize;
  float elementCnt;
  tex.GetDimensions(texSize.x, texSize.y, elementCnt);
  float2 texelSize = 1.0f / texSize;
  
  float4 uvQuadAjust = uvQuad - texelSize.xyxy;
  //sample four quads
  bil0 = SampleSATSumFP_CubeU(tex, arrayIndex, texIndex, uvQuadAjust + (int2(0, 0) * texelSize).xyxy);
  bil1 = SampleSATSumFP_CubeU(tex, arrayIndex, texIndex, uvQuadAjust + (int2(1, 0) * texelSize).xyxy);
  bil2 = SampleSATSumFP_CubeU(tex, arrayIndex, texIndex, uvQuadAjust + (int2(0, 1) * texelSize).xyxy);
  bil3 = SampleSATSumFP_CubeU(tex, arrayIndex, texIndex, uvQuadAjust + (int2(1, 1) * texelSize).xyxy);
  
  //avg
  float2 size = (uvQuad.zw - uvQuad.xy) * texSize;
  float invArea = 1.0f / (size.x * size.y);
  bil0 *= invArea;
  bil1 *= invArea;
  bil2 *= invArea;
  bil3 *= invArea;
}

float CalcShadow_SAVSM_FP_Bil(
  Texture2DArray tex,
  const in uint arrayIndex,
  const in float2 uvLUBil,
  const in float2 filterSize,
  const in float4 bilWeights,
  const in float reciever)
{
  float2 texSize;
  float numElements;
  tex.GetDimensions(texSize.x, texSize.y, numElements);
  float2 texelSize = 1.0f / texSize;
  
  float4 bil0 = 0.0f;
  float4 bil1 = 0.0f;
  float4 bil2 = 0.0f;
  float4 bil3 = 0.0f;
  
  SampleSATBilFP(tex, arrayIndex, float4(uvLUBil, uvLUBil + filterSize * texelSize),
               bil0, bil1, bil2, bil3);
               
  
  //tranform to moments
  float2 moments0 = GetMomentsFP4(bil0);
  float2 moments1 = GetMomentsFP4(bil1);
  float2 moments2 = GetMomentsFP4(bil2);
  float2 moments3 = GetMomentsFP4(bil3);
  
  
  //bilinear
  float2 moments = 0.0f;
  float4 mx = float4(moments0.x, moments1.x, moments2.x, moments3.x);
  float4 my = float4(moments0.y, moments1.y, moments2.y, moments3.y);
  moments.x = dot(bilWeights, mx);
  moments.y = dot(bilWeights, my);
  
  return ChebyshevUpperBound(moments, reciever, 0.001f, vsmReduceBlending);
}

float CalcShadow_SAVSM_FP(Texture2DArray tex, uint arrayIndex, float2 uv, float reciever, float size)
{
  float2 texSize;
  float numElements;
  tex.GetDimensions(texSize.x, texSize.y, numElements);
  
  float2 dtdx = ddx(uv);
  float2 dtdy = ddy(uv);
  
  float2 filterSize = 0.0f;
  float2 uvLU = 0.0f;
  float2 minQuadSize = size;
  float2 maxQuadSize = size + 2.0f;
  float4 filterQuad = GetFilterQuad(uv, dtdx, dtdy, texSize,
                      minQuadSize, maxQuadSize);
  filterSize = filterQuad.xy;
  uvLU = filterQuad.zw;

  float2 uvLUBil = 0.0f;
  float4 bilWeights = 0.0f;
  GetBilUVAndWeights(uvLU, texSize,
                     uvLUBil, bilWeights);
  
  float shadow = 1.0f;
  return CalcShadow_SAVSM_FP_Bil(tex, arrayIndex, uvLUBil, filterSize, bilWeights, reciever);
}


float CalcShadow_SAVSM_FP_Bil(
  TextureCubeArray tex,
  uint arrayIndex,
  uint texIndex,
  float2 uvLUBil,
  float2 filterSize,
  float4 bilWeights,
  float reciever)
{
  float2 texSize;
  float elementCnt;
  tex.GetDimensions(texSize.x, texSize.y, elementCnt);
  float2 texelSize = 1.0f / texSize;
  
  float4 bil0;
  float4 bil1;
  float4 bil2;
  float4 bil3;
  SampleSATBilFP(tex, arrayIndex, texIndex, float4(uvLUBil, uvLUBil + filterSize * texelSize),
               bil0, bil1, bil2, bil3);
  
  //tranform to moments
  float2 moments0 = GetMomentsFP4(bil0);
  float2 moments1 = GetMomentsFP4(bil1);
  float2 moments2 = GetMomentsFP4(bil2);
  float2 moments3 = GetMomentsFP4(bil3);
  
  //bilinear
  float2 moments;
  moments.x = dot( bilWeights, float4(moments0.x, moments1.x, moments2.x, moments3.x) );
  moments.y = dot( bilWeights, float4(moments0.y, moments1.y, moments2.y, moments3.y) );
  return ChebyshevUpperBound(moments, reciever, 0.001f, vsmReduceBlending);
}

float CalcShadow_SAVSM_FP(TextureCubeArray tex, uint arrayIndex, float3 dir, float reciever, float size)
{
  float2 texSize;
  float elementCnt;
  tex.GetDimensions(texSize.x, texSize.y, elementCnt);

  uint texIndex = GetCubeMapSampleIndex(dir);
  
  float2 uv = GetTexelUV(dir, texIndex);
  float2 dtdx = ddx(uv);
  float2 dtdy = ddy(uv);
  
  float2 filterSize;
  float2 uvLU;
  float4 filterQuad = GetFilterQuad(uv, dtdx, dtdy, texSize,
                size, size + 2.0f);
  filterSize = filterQuad.xy;
  uvLU = filterQuad.zw;

  float2 uvLUBil;
  float4 bilWeights;
  GetBilUVAndWeights(uvLU, texSize,
                     uvLUBil, bilWeights);
                     
  return CalcShadow_SAVSM_FP_Bil(tex, arrayIndex, texIndex, uvLUBil, filterSize, bilWeights, reciever);
}
    
    ]]>
  </shader>
</effect>
