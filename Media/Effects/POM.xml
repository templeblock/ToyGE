<?xml version="1.0" encoding="utf-8"?>

<effect>
  <shader>
    <![CDATA[
    
void GetTBN(
  float3 normal,
  float3 tangent,
  out float3 T, 
  out float3 B,
  out float3 N)
{
  N = normalize(normal);
	T = normalize(tangent);
	B = cross(N, T);
}
    
float3 WorldToTex(float3 T, float3 B, float3 N, float3 vec)
{
  float3x3 texToWorld = float3x3(T, B, N);
  float3x3 worldToTex = transpose(texToWorld);
  float3 v = mul(vec, worldToTex);
  return v;
}

float3 TexToWorld(float3 T, float3 B, float3 N, float3 vec)
{
  float3x3 texToWorld = float3x3(T, B, N);
  float3 v = mul(vec, texToWorld);
  return v;
}
    
float2 ParallaxMapping(float3 normal, float3 tangent, float3 view, float2 uv, Texture2D tex, uint heightChannel, float scale)
{
  float3 T, B, N;
  GetTBN(normal, tangent, T, B, N);
  float3 v = WorldToTex(T, B, N, view);
  float h = tex.Sample(samplerLinear, uv)[heightChannel];
  float s = scale;
  float b = 0.01f;
  float hAdj = h * s + b;
  float limit = 0.07f;
  hAdj = min( limit, hAdj / max(0.0001f, v.z) );
  float2 uvNew = uv + v.xy * hAdj;
  return uvNew;
}

#define POM_MAXSTEPS 50

void ParallaxOcclusionMapping(
  float3 normal,
  float3 tangent,
  float3 view,
  float2 uv,
  Texture2D heightTex,
  uint heightChannel,
  float scale,
  out float3 posT,
  out float3 vecW)
{
  const float bias = 0.01f;
  
  float3 T, B, N;
  GetTBN(normal, tangent, T, B, N);
  
  float3 v = WorldToTex(T, B, N, view);
  
  int stepIndex = 0;
  int maxSteps = POM_MAXSTEPS;
  
  if(v.z >= 0.99f)
  {
    maxSteps = 0;
  }
  
  float xBound = v.x > 0.0f ? ceil(uv.x) : floor(uv.x);
  float yBound = v.y > 0.0f ? ceil(uv.y) : floor(uv.y);
  
  if(abs(v.x) < 0.0001f)
    v.x = 0.0001f * sign(v.x);
  if(abs(v.y) < 0.0001f)
    v.y = 0.0001f * sign(v.y);
  if(abs(v.z) < 0.0001f)
    v.z = 0.0001f * sign(v.z);
  
  //float dx = (xBound - tex.x) / v.x;
  //float dy = (yBound - tex.y) / v.y;
  
  float maxH = 1.0f * scale + bias;
  float dz = maxH / v.z;
  
  float d = dz;
  float3 begin = float3(uv.xy, 0.0f) + v * d;
  
  float3 texSize;
  heightTex.GetDimensions(0, texSize.x, texSize.y, texSize.z);
  
  float2 texel = 1.0f / texSize.xy;
  
  float3 step = 
    (abs(v.x) * texSize.x > abs(v.y) * texSize.y)
    ? (v / abs(v.x) * texel.x)
    : (v / abs(v.y) * texel.y);
  step *= -1.0f;
  
  if( d != dz )
  {
    //float jitter = (((uint)(uv.x * texSize.x) + (uint)(uv.y * texSize.y)) & 1) * 0.5f;
    //begin += step * jitter;
    begin += step  * 0.5f;
  }
  
  float3 p = begin;
  
  float stride = 4.0f;
  //step *= stride;
  
  for(
    ;
    stepIndex < maxSteps;
    ++stepIndex, p += step * stride)
  {
    float h = heightTex.SampleLevel(samplerLinear, p.xy, 0)[heightChannel];
    h = h * scale + bias;
    if( p.z <= h )
    {
      break;
    }
  }
  
  float3 p0 = p;
  float3 p1 = p0 - step * stride;
  
  float minStride = 1.0f / (1 << 3);
  while(stride > minStride)
  {
    float3 mid = p1 + step * stride * 0.5f;
    p = mid;
    float h = heightTex.SampleLevel(samplerLinear, mid.xy, 0)[heightChannel];
    h = h * scale + bias;
    if( mid.z <= h )
      p0 = mid;
    else
      p1 = mid;
      
    stride *= 0.5f;
  }
  
  posT = p;
  vecW = TexToWorld(T, B, N, posT - float3(uv, 0));
}
    
    ]]>
  </shader>
</effect>
