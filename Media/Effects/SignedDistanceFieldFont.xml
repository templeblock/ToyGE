<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>

  <variable type="Texture2DArray" name="sdfComputeInTex"/>

  <variable type="Texture2DArray" name="edgeTex"/>

  <variable type="cbuffer" name="cb_sdfCompute">
    <variable type="uint2" name="glyphSize"/>
    <variable type="uint2" name="sdfComputeInTexSize"/>
    <variable type="uint2" name="sdfTexSize"/>
    <variable type="uint" name="sliceIndex"/>
  </variable>

  <variable type="cbuffer" name="cb_computeEdge">
    <variable type="float4" name="texSize"/>
  </variable>

  <variable type="Texture2D" name="computeEdgeInTex"/>
  <variable type="Texture2D" name="downSampleInTex"/>

  <shader>
    <![CDATA[
    
float DownSample4x4PS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 uvs[4] = 
  {
    vsOut.tex.xy + float2(-0.25, -0.25) * texSize.zw,
    vsOut.tex.xy + float2( 0.25, -0.25) * texSize.zw,
    vsOut.tex.xy + float2(-0.25,  0.25) * texSize.zw,
    vsOut.tex.xy + float2( 0.25,  0.25) * texSize.zw
  };
  
  float4 sample;
  [unroll] for(int i = 0; i < 4; ++i)
  {
    sample[i] = downSampleInTex.SampleLevel(samplerLinearClamp, uvs[i], 0).x;
  }
  
  return dot(sample, 0.25);
}
    
    ]]>
  </shader>

  <technique name="DownSample4x4">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="DownSample4x4PS"/>
    </pass>
  </technique>
  

  <shader>
    <![CDATA[
    
float2 ComputeEdgeDirectionPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float samples[3][3];
  
  float2 leftTopPos = floor( (vsOut.pos.xy - 0.5) / float2(glyphSize) ) * float2(glyphSize) + 0.5;
  float2 rightBorttomPos = leftTopPos + glyphSize - 1.0;
  
  float4 uvBound = float4(leftTopPos, rightBorttomPos) * texSize.zwzw;
  
  [unroll] for(int x = -1; x <= 1; ++x)
  {
    [unroll] for(int y = -1; y <= 1; ++y)
    {
      float2 uv = vsOut.tex.xy + float2(x, y) * texSize.zw;
      //uv = clamp(uv, uvBound.xy, uvBound.zw);
      
      if(any(uv < uvBound.xy) || any(uv > uvBound.zw))
        samples[y + 1][x + 1] = 0.0f;
      else
        samples[y + 1][x + 1] = computeEdgeInTex.SampleLevel(samplerPoint, uv, 0).x;
    }
  }
  
  float dadx = 0.0f;
  [unroll] for(int i = 0; i < 3; ++i)
  {
    float w = 1.0f;
    if(i == 0)
      w = 1.414f;
    dadx += (samples[i][2] - samples[i][0]) * w;
  }
  
  float dady = 0.0f;
  [unroll] for(int j = 0; j < 3; ++j)
  {
    float w = 1.0f;
    if(j == 0)
      w = 1.414f;
    dady += (samples[2][j] - samples[0][j]) * w;
  }
  
  float2 g = float2(dadx, dady);
  
  g /= max(1e-5, length(g));
  
  return g;
}
    
    ]]>
  </shader>

  <technique name="ComputeEdgeDirection">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ComputeEdgeDirectionPS"/>
    </pass>
  </technique>
  
  
  <shader>
    <![CDATA[
    
float ComputeSignedDistanceFieldPS(PostProcessVSOut vsOut) : SV_TARGET
{
  uint2 pixelPos = uint2(vsOut.pos.xy);
  
  uint2 glyphPos = pixelPos / glyphSize;
  uint2 pixelPosInGlyph = pixelPos - glyphPos * glyphSize;
  uint2 texGlyphDims = sdfTexSize / glyphSize;
  uint glyphIndex = sliceIndex * texGlyphDims.x * texGlyphDims.y + dot(glyphPos, uint2(1, texGlyphDims.x));
  
  uint2 inGlyghSize = glyphSize;// * 2;
  uint2 inTexGlyphDims = sdfComputeInTexSize / inGlyghSize;
  uint inSlice = glyphIndex / inTexGlyphDims.x / inTexGlyphDims.y;
  uint inGlyphIndexInSlice = glyphIndex - inSlice * inTexGlyphDims.x * inTexGlyphDims.y;
  uint2 inGlyphPos = uint2(inGlyphIndexInSlice % inTexGlyphDims.x, inGlyphIndexInSlice / inTexGlyphDims.x);
  
  uint2 inPixelPosStart = inGlyphPos * inGlyghSize;
  uint2 inSamplePos0 = inPixelPosStart + pixelPosInGlyph;// * 2;
  uint2 inSamplePos1 = inSamplePos0 + uint2(1, 0);
  uint2 inSamplePos2 = inSamplePos0 + uint2(0, 1);
  uint2 inSamplePos3 = inSamplePos0 + uint2(1, 1);
  
  float sample0 = sdfComputeInTex.Load(uint4(inSamplePos0, inSlice, 0)).x;
  
  /*
  float sample1 = sdfComputeInTex.Load(uint4(inSamplePos1, inSlice, 0)).x;
  float sample2 = sdfComputeInTex.Load(uint4(inSamplePos2, inSlice, 0)).x;
  float sample3 = sdfComputeInTex.Load(uint4(inSamplePos3, inSlice, 0)).x;
  */
  
  //float a = 0.25 * dot(float4(sample0, sample1, sample2, sample3), 1);
  float a = sample0;
  
  //float ddx = 0.5 * (sample1 - sample0 + sample3 - sample2);
  //float ddy = 0.5 * (sample2 - sample0 + sample3 - sample1);
  
  float dadx = ddx(a);
  float dady = ddy(a);
  
  bool bSwapDDX = dadx < 0.0f;
  bool bSwapDDY = dady < 0.0f;
  
  dadx = abs(dadx);
  dady = abs(dady);
  
  //if(length(float2(dadx, dady)) == 0)
  //  return sample0;
  
  //float2 g = normalize(float2(max(dadx, dady), min(dadx, dady)));
  float2 g = edgeTex.Load(uint4(inSamplePos0, inSlice, 0)).xy;
  
  if( length(g) < 1e-5 )
    return a;
  
  g = abs(g);
  if(g.x < g.y)
    g.xy = g.yx;
    
  //if( g.x < 1e-5 )
  //  g.x = 1.0f;
  
  float a1 = 0.5 * g.y / g.x;
  
  float d;
  if(a >= 0 && a <= a1)
  {
    d = dot(g, 0.5) - sqrt(2.0 * g.x * g.y * a);
  }
  else if(a >= a1 && a <= 1- a1)
  {
    d = (0.5 - a) * g.x;
  }
  else
  {
    d = -dot(g, 0.5) + sqrt(2.0 * g.x * g.y * (1.0 - a));
  }
  
  d *= -1.0;
  //if(d < 0)
  //  d += 1.0;
  
  return (d + 1.0) * 0.5;
}
    
    ]]>
  </shader>

  <technique name="ComputeSignedDistanceField">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ComputeSignedDistanceFieldPS"/>
    </pass>
  </technique>
  
</effect>