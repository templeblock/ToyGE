<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="Defines.xml"/>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>
  <include name="Util.xml"/>
  
  <variable type="cbuffer" name="cb_coc">
    <variable type="float" name="focalLength"/>
    <variable type="float" name="focalDistance"/>
    <variable type="float" name="aperture"/>
    <variable type="float" name="pixelsPerMM"/>
    <variable type="float2" name="camNearFar"/>
  </variable>
  
  <variable type="Texture2D" name="linearDepthTex"/>
    
  <shader>
    <![CDATA[
#define MAX_COC 10

float ComputeCoCPS(PostProcessVSOut vsOut) : SV_TARGET
{
    float f = focalLength; // in mm
    float p = linearDepthTex.SampleLevel(samplerPoint, vsOut.tex, 0).x;
    p = p * (camNearFar.y - camNearFar.x) + camNearFar.x;
    float o = focalDistance;
    float d = aperture; // in mm
  
    p *= 1000.0f;
  
    float c = d * f * (o - p) / (p * (o - f));
    
    float coc = c * pixelsPerMM;
    
    float alpha = min( 1.0f / (PI * coc * coc), 1.0f / (PI) );
    
    return min(MAX_COC, abs(coc));
}
  
    ]]>
  </shader>

  <technique name="ComputeCoC">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ComputeCoCPS"/>
    </pass>
  </technique>
  
  <variable type="Texture2D" name="cocTex"/>
  <variable type="Texture2D" name="tileMaxTex"/>

  <shader>
    <![CDATA[
  
#define TILE_SIZE (MAX_COC * 2)
  
float3 SetupTile(PostProcessVSOut vsOut, float2 dir)
{
    uint2 tileStart = uint2(vsOut.pos.xy) * TILE_SIZE * dir + (1.0f - dir) * uint2(vsOut.pos.xy);
    
    float maxCoC = 0.0f;
    float maxDepth = 0.0f;
    float minDepth = 1.0f;
    
    [unroll] for(int i = 0; i < TILE_SIZE; ++i)
    {
        uint2 samplePos = tileStart + i * dir;
        
    #ifdef TILE_INIT
        float coc = cocTex.Load(uint3(samplePos, 0)).x;
        float depth = linearDepthTex.Load(uint3(samplePos, 0)).x;
        
        maxCoC = max(maxCoC, coc);
        maxDepth = max(maxDepth, depth);
        minDepth = min(minDepth, depth);
    #else
        float3 tileMax = tileMaxTex.Load(uint3(samplePos, 0)).xyz;
        
        maxCoC = max(maxCoC, tileMax.x);
        maxDepth = max(maxDepth, tileMax.y);
        minDepth = min(minDepth, tileMax.z);
    #endif
        
    }
    
    return float3(maxCoC, maxDepth, minDepth);
}

float3 SetupTileXPS(PostProcessVSOut vsOut) : SV_TARGET
{
    return SetupTile(vsOut, float2(1.0f, 0.0f));
}

float3 SetupTileYPS(PostProcessVSOut vsOut) : SV_TARGET
{
    return SetupTile(vsOut, float2(0.0f, 1.0f));
}
  
    ]]>
  </shader>
  
  <technique name="SetupTileX">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="SetupTileXPS"/>
    </pass>
  </technique>
  
  <technique name="SetupTileY">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="SetupTileYPS"/>
    </pass>
  </technique>


  <variable type="cbuffer" name="cb_neighborTile">
    <variable type="float4" name="texSize"/>
  </variable>
  
  <shader>
    <![CDATA[
  
float3 NeighborTilePS(PostProcessVSOut vsOut) : SV_TARGET
{
    float3 neighborMax = 0.0f;
    neighborMax.z = 1.0f;
    
    [unroll] for(int i = -1; i <= 1; ++i)
    {
        [unroll] for(int j = -1; j <= 1; ++j)
        {
            float2 sampleUV = vsOut.tex + float2(i, j) * texSize.zw;
            float3 tileMax = tileMaxTex.SampleLevel(samplerPointClamp, sampleUV, 0).xyz;
            neighborMax.xy = max(neighborMax.xy, tileMax.xy);
            neighborMax.z = min(neighborMax.z, tileMax.z);
        }
    }
    
    return neighborMax;
}
  
    ]]>
  </shader>
  
  <technique name="NeighborTile">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="NeighborTilePS"/>
    </pass>
  </technique>


  <shader>
    <![CDATA[
  
float2 ComputeAlphaPS(PostProcessVSOut vsOut) : SV_TARGET
{
    float coc = cocTex.SampleLevel(samplerPoint, vsOut.tex, 0).x;
    float2 tileMaxDepth = tileMaxTex.Load(uint3(uint2(vsOut.pos.xy) / TILE_SIZE, 0)).yz;
    
    float alpha = min( 1.0f / (PI * coc * coc), 1.0f / (PI * 0.5 * 0.5) );
    
    float depth = linearDepthTex.SampleLevel(samplerPoint, vsOut.tex, 0).x;
    
    float tileMidDepth = dot(float2(0.5, 0.5), tileMaxDepth);
    
    //float depthCmpScale = (camNearFar.y - camNearFar.x) / 2.0f;
    //float d = (tileMaxDepth - depth) * depthCmpScale;
    float d = (tileMidDepth - depth) * (camNearFar.y - camNearFar.x)  / 0.5f;
    float depthCmp = smoothstep(0.0f, 1.0f, d);
    
    return float2(alpha * depthCmp, alpha * (1.0f - depthCmp));
}
  
    ]]>
  </shader>
  
  <technique name="ComputeAlpha">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ComputeAlphaPS"/>
    </pass>
  </technique>


  <variable type="Texture2D" name="sceneTex"/>
  <variable type="Texture2D" name="alphaTex"/>

  <shader>
    <![CDATA[
  
#define NUM_SAMPLES 16
    
float2 GetSampleOffset(int index)
{
  static const float2 sampleOffsets[NUM_SAMPLES] = {
    float2(0.2069841f, 0.2245269f),
    float2(0.525808f, -0.2310817f),
    float2(0.1383943f, 0.9056122f),
    float2(0.6633009f, 0.5129843f),
    float2(-0.4002792f, 0.3727058f),
    float2(0.07912822f, -0.6512921f),
    float2(-0.7726067f, -0.5151217f),
    float2(-0.3843193f, -0.1494132f),
    float2(-0.9107782f, 0.2500633f),
    float2(0.6940153f, -0.7098927f),
    float2(-0.1964669f, -0.379389f),
    float2(-0.4769286f, 0.1840863f),
    float2(-0.247328f, -0.8798459f),
    float2(0.4206541f, -0.714772f),
    float2(0.5829348f, -0.09794202f),
    float2(0.3691838f, 0.4140642f)
  };
  
  return sampleOffsets[index];
}
  
void BlurPS(
    PostProcessVSOut vsOut,
    out float3 finalColor : SV_TARGET)
    //out float4 foreground : SV_TARGET0,
    //out float4 background : SV_TARGET1)
{
    float3 tileMax = tileMaxTex.Load(uint3(uint2(vsOut.pos.xy) / TILE_SIZE, 0)).xyz;
    
    float3 centerColor = sceneTex.SampleLevel(samplerPoint, vsOut.tex, 0).xyz;
    
    float centerDepth = linearDepthTex.SampleLevel(samplerPoint, vsOut.tex, 0).x;
    
    float tileMaxCoC = tileMax.x;
    
    float4 foreground = 0.0f;
    float4 background = 0.0f;
    
    [unroll] for(int i = 0; i < NUM_SAMPLES; ++i)
    {
        float2 offset = GetSampleOffset(i) * tileMaxCoC * texSize.zw;
        float2 samplePos = vsOut.tex + offset;
        float3 sampleColor = sceneTex.SampleLevel(samplerLinearClamp, samplePos, 0).xyz;
        float2 sampleAlpha = alphaTex.SampleLevel(samplerLinearClamp, samplePos, 0).xy;
        float sampleCoC = cocTex.SampleLevel(samplerLinearClamp, samplePos, 0).x;
        float sampleDepth = linearDepthTex.SampleLevel(samplerLinearClamp, samplePos, 0).x;
        
        
       if(length(offset) <= sampleCoC)
        {
            float d = saturate( (centerDepth - sampleDepth) * (camNearFar.y - camNearFar.x) + 1.0f );
            float a = 1.0f / (PI * sampleCoC * sampleCoC) * d;
            
            //a = sampleAlpha.x;
            
            foreground.xyz += sampleColor * a;
            foreground.w += a;
            background.xyz += sampleColor * 1.0f;//sampleAlpha.y;
            background.w += 1.0f;//sampleAlpha.y;
        }
    }
    
    foreground.xyz /= max(1e-4, foreground.w);
    background.xyz /= max(1e-4, background.w);
    
    
    
    float normFac = 2.0f * (PI * tileMaxCoC * tileMaxCoC) / NUM_SAMPLES;
    foreground.w *= normFac;
    //background.w *= normFac;
    
    //finalColor = lerp(background.rgb, foreground.rgb, saturate(foreground.a));
    finalColor = foreground.xyz;
}
  
    ]]>
  </shader>
  
  <technique name="Blur">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="BlurPS"/>
    </pass>
  </technique>

</effect>