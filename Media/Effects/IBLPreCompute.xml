<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="Defines.xml"/>
  <include name="PostProcess.xml"/>
  <include name="Util.xml"/>
  <include name="CommonState.xml"/>
  <include name="Lighting.xml"/>

  <variable type="cbuffer" name="cb_prefilterEnvMap">
    <variable type="float4" name="textureSize"/>
  </variable>

  <variable type="TextureCube" name="envMap"/>
  
  <shader>
    <![CDATA[
    
#define NUM_SAMPLES 256
    
float3 ImportanceSampling(float2 sample2d, float roughness, float3 N)
{
  float a = roughness * roughness;
  
  float phi = 2 * PI * sample2d.x;
  float cosTheta = sqrt( max(1e-4, 1 - sample2d.y) / ( 1 + (a*a - 1) * sample2d.y ) );
  float sinTheta = sqrt( max(1e-4, 1 - cosTheta * cosTheta) );
  float3 H = 0;
  H.x = sinTheta * sin(phi);
  H.y = cosTheta;
  H.z = sinTheta * cos(phi);
  
  float3 Tx = abs(N.x) < 0.999 ? float3(1.0f, 0.0f, 0.0f) : float3(0.0f, 1.0f, 0.0f);
  float3 Tz = normalize(cross(Tx, N));
  Tx = cross(N, Tz);
  return H.x * Tx + H.y * N + H.z * Tz;
}
    
float3 PrefilterEnvMap(float roughness, float3 R)
{
  float3 N = R;
  float3 V = R;
  float3 colorSum = 0.0f;
  float weightSum = 0.0f;
  
  for(uint i = 0; i < NUM_SAMPLES; ++i)
  {
    float2 sample2d = Hammersley2d(i, NUM_SAMPLES);
    float3 H = ImportanceSampling(sample2d, roughness, N);
    float3 L = 2 * H - V;
    
    float NoL = saturate(dot(N, L));
    if(NoL > 0)
    {
      colorSum += envMap.SampleLevel(samplerLinear, L, 0).xyz * NoL;
      weightSum += NoL;
    }
  }
  
  return colorSum / max(1e-4, weightSum);
}

struct PrefilterEnvMapVSOut
{
  float4 pos : POSITION;
};

PrefilterEnvMapVSOut PrefilterEnvMapVS(
    float2 pos : POSITION,
    float2 tex : TEXCOORD)
{
	PrefilterEnvMapVSOut vsOut;
	vsOut.pos = float4(pos, 0.0f, 1.0f);
	return vsOut;
}

struct PrefilterEnvMapGSOut
{
  float4 pos : SV_POSITION;
  uint arrayIndex : SV_RenderTargetArrayIndex;
};

[maxvertexcount(18)]
void PrefilterEnvMapGS(
  triangle PrefilterEnvMapVSOut vsOut[3], 
  inout TriangleStream<PrefilterEnvMapGSOut> output)
{
  PrefilterEnvMapGSOut gsOut;
  
  for(uint faceIndex = 0; faceIndex < 6; ++faceIndex)
  {
    for(uint vertexIndex = 0; vertexIndex < 3; ++vertexIndex)
    {
      gsOut.pos = vsOut[vertexIndex].pos;
      gsOut.arrayIndex = faceIndex;
      output.Append(gsOut);
    }
    output.RestartStrip();
  }
}

void GetLookAndUpVec(uint index, out float3 look, out float3 up)
{
  static const float3 lookArray[6] = 
  {
    float3( 1.0f,  0.0f,  0.0f),
    float3(-1.0f,  0.0f,  0.0f),
    float3( 0.0f,  1.0f,  0.0f),
    float3( 0.0f, -1.0f,  0.0f),
    float3( 0.0f,  0.0f,  1.0f),
    float3( 0.0f,  0.0f, -1.0f)
  };
  
  static const float3 upArray[6] = 
  {
    float3( 0.0f,  1.0f,  0.0f),
    float3( 0.0f,  1.0f,  0.0f),
    float3( 0.0f,  0.0f, -1.0f),
    float3( 0.0f,  0.0f,  1.0f),
    float3( 0.0f,  1.0f,  0.0f),
    float3( 0.0f,  1.0f,  0.0f)
  };
  
  look = lookArray[index];
  up = upArray[index];
}
    
float4 PrefilterEnvMapPS(PrefilterEnvMapGSOut gsOut) : SV_TARGET
{
  float3 Wz = 0.0f;
  float3 Wy = 0.0f;
  GetLookAndUpVec(gsOut.arrayIndex, Wz, Wy);
  float3 Wx = cross(Wy, Wz);
  float2 size = textureSize.xy;
  float roughness = lerp(0.1f, 0.9f, textureSize.z);
  
  float2 texelIndex = gsOut.pos.xy - 0.5f;
  
  float3 R = (texelIndex.x - size.x / 2) * Wx + (-texelIndex.y + size.y / 2) * Wy + size.x / 2 * Wz;
  R = normalize(R);
  
  return float4(PrefilterEnvMap(roughness, R), 1.0f);
  //return float4(envMap.SampleLevel(samplerLinear, R, 0).xyz, 1.0f);
}


float2 IntegrateBRDF(float roughness, float NoV)
{
  float3 N = float3(0.0f, 1.0f, 0.0f);
  float3 V = 0.0f;
  V.x = sqrt(max(1e-4, 1.0f - NoV * NoV));
  V.y = NoV;
  
  float2 resultSum = 0.0f;
  
  for(uint i = 0; i < NUM_SAMPLES; ++i)
  {
    float2 sample2d = Hammersley2d(i, NUM_SAMPLES);
    float3 H = ImportanceSampling(sample2d, roughness, N);
    float3 L = 2 * H - V;
    
    float VoH = saturate(dot(V, H));
    float NoH = saturate(dot(N, H));
    float NoL = saturate(dot(N, L));
    
    if(NoL > 0)
    {
      float D = NDF_GGX(N, H, roughness);
      float G = G_Smith(N, L, V, roughness);
      float G_t = G * VoH / max(1e-4, NoV * NoH);
      float F_t = pow(1.0f - VoH, 5);
      
      resultSum.x += (1.0f - F_t) * G_t;
      resultSum.y += F_t * G_t;
    }
  }
  
  return resultSum / NUM_SAMPLES;
}

float2 LUTPS(PostProcessVSOut vsOut) : SV_TARGET
{
  //float2 texCoord = vsOut.tex;// vsOut.pos.xy / textureSize.xy;
  float2 texCoord = vsOut.pos.xy / textureSize.xy;
  float NoV = texCoord.x;
  float roughness = lerp(0.1f, 0.9f, texCoord.y);
  
  return IntegrateBRDF(roughness, NoV);
}
    
    ]]>
  </shader>

  <technique name="PrefilterEnvMap">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PrefilterEnvMapVS"/>
      <gs entry="PrefilterEnvMapGS"/>
      <ps entry="PrefilterEnvMapPS"/>
    </pass>
  </technique>

  <technique name="LUT">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="LUTPS"/>
    </pass>
  </technique>
  
</effect>