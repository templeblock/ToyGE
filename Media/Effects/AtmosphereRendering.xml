<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="Defines.xml"/>
  <include name="PostProcess.xml"/>
  <include name="CommonState.xml"/>
  <include name="Shadow.xml"/>

  <variable type="Texture2D" name="opticalDepthLUT"/>
  <variable type="Texture3D" name="inScatteringLUTR"/>
  <variable type="Texture3D" name="inScatteringLUTM"/>

  <variable type="cbuffer" name="cb_preComputeLUT">
    <variable type="float4" name="lutSize"/>
    <variable type="float2" name="wqCoord"/>
    <variable type="uint" name="depthSlice"/>
  </variable>

  <shader>
    <![CDATA[
    
void GetRaySphereIntersection(float3 rayOrigin,
                              float3 rayDir,
                              float3 sphereCenter,
                              float  sphereRadius,
                              out float2 intersection)
{
    // http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection
    rayOrigin -= sphereCenter;
    float A = dot(rayDir, rayDir);
    float B = 2 * dot(rayOrigin, rayDir);
    float C = dot(rayOrigin, rayOrigin) - sphereRadius * sphereRadius;
    float D = B*B - 4*A*C;
    // If discriminant is negative, there are no real roots hence the ray misses the
    // sphere
    if( D<0 )
    {
        intersection = -1;
    }
    else
    {
        D = sqrt(D);
        intersection = float2(-B - D, -B + D) / (2*A); // A must be positive here!!
    }
}

float PhaseFunction_R(float cosTheta)
{
  return 3.0 / (16.0 * PI) * (1 + cosTheta * cosTheta);
}

float PhaseFunction_M(float g, float cosTheta)
{
  float g2 = g * g;
  
  return 3.0 / (8.0 * PI) * (1-g2)/(2+g2) * (1 + cosTheta*cosTheta)/pow(1+g2-(g+g)*cosTheta, 3.0/2.0);
}

float3 ComputeAttenuation(float height, float cosZenith)
{
  height = clamp(height, 10.0, atmosphereTopHeight - 10.0);
  float2 lutCoord = float2((height - 10.0) / (atmosphereTopHeight - 20.0), cosZenith * 0.5f + 0.5f);
  float2 densityToSampleAccum = opticalDepthLUT.SampleLevel(samplerLinearClamp, lutCoord, 0).xy;
    
  float3 attenuation = exp(- (attenuationR * densityToSampleAccum.x + attenuationM * densityToSampleAccum.y) );
  return attenuation;
}

float3 ComputeAttenuationPoints(float3 p0, float3 p1, float3 earthCenter, float earthRadius)
{
  float h0 = length(p0 - earthCenter) - earthRadius;
  float h1 = length(p1 - earthCenter) - earthRadius;
  
  float ha = h0;
  float hb = h1;
  float3 pa = p0;
  float3 pb = p1;
  if(ha > hb)
  {
    ha = h1;
    hb = h0;
    pa = p1;
    pb = p0;
  }
  
  float3 dir = normalize(pb - pa);
  
  if( hb - ha < 1.0 )
    return 1.0;
  
  float3 zenithDir = normalize(pa - earthCenter);
  float cosZenith = dot(dir, zenithDir);
  float3 Ta = ComputeAttenuation(ha, cosZenith);
  float3 Tb = ComputeAttenuation(hb, cosZenith);
  return Ta / (Tb < 1e-8 ? 1 : Tb);
}

#define HEIGHT_POWER 0.5
#define HEIGHT_MARGIN 16.0
#define VIEW_ZENITH_POWER 0.2
#define VIEW_SUN_POWER 1.5

void GetScatteringComputeParams1(
  float4 coord,
  out float height,
  out float cosViewZenith,
  out float cosSunZenith,
  out float cosViewSun)
{
  coord.xzw = (coord.xzw - 0.5 / lutSize.xzw) / (1.0 - 1.0/lutSize.xzw);
  
  coord.x = pow(coord.x, 1.0 / HEIGHT_POWER);
  height = lerp(HEIGHT_MARGIN, atmosphereTopHeight - HEIGHT_MARGIN, coord.x);
  
  //cosViewZenith = coord.y * 2.0 - 1.0;
  
  
  float r = earthRadius + height;
  float cosHorizon = -sqrt(r * r - earthRadius * earthRadius) / r;
  if(coord.y > 0.5)
  {
    coord.y = (coord.y - (0.5 + 0.5 / lutSize.y)) / (0.5 - 1.0 / lutSize.y);
    coord.y = pow(coord.y, 1.0 / VIEW_ZENITH_POWER);
    cosViewZenith = max(cosHorizon + 1e-4, lerp(cosHorizon, 1.0, coord.y));
  }
  else
  {
    coord.y = (coord.y - 0.5/lutSize.y) / (0.5 - 1.0 / lutSize.y);
    coord.y = pow(coord.y, 1.0 / VIEW_ZENITH_POWER);
    cosViewZenith = min(cosHorizon - 1e-4, lerp(cosHorizon, -1.0, coord.y));
  }
  
  
  
  //cosSunZenith = coord.z * 2.0 - 1.0;
  
  cosSunZenith = tan((2.0 * coord.z - 1.0 + 0.26) * 1.1) / tan(1.26 * 1.1);
  cosSunZenith = clamp(cosSunZenith, -1, 1);
  
  
  cosViewSun = sign(coord.w - 0.5) * pow( abs(coord.w - 0.5) * 2.0, 1.0/VIEW_SUN_POWER ) * 0.5 + 0.5;
  cosViewSun = cos(cosViewSun * PI);
  
  
  cosViewZenith = clamp(cosViewZenith, -1, 1);
  cosSunZenith = clamp(cosSunZenith, -1, 1);
  cosViewSun = clamp(cosViewSun, -1, 1);
  
  float D = (1.0 - cosViewZenith * cosViewZenith) * (1.0 - cosSunZenith  * cosSunZenith);
    
    // !!!!  IMPORTANT NOTE regarding NVIDIA hardware !!!!

    // There is a very weird issue on NVIDIA hardware with clamp(), saturate() and min()/max() 
    // functions. No matter what function is used, fCosViewZenithAngle and fCosSunZenithAngle
    // can slightly fall outside [-1,+1] range causing D to be negative
    // Using saturate(D), max(D, 0) and even D>0?D:0 does not work!
    // The only way to avoid taking the square root of negative value and obtaining NaN is 
    // to use max() with small positive value:
    D = sqrt( max(D, 1e-20) );
    
    // The issue was reproduceable on NV GTX 680, driver version 9.18.13.2723 (9/12/2013).
    // The problem does not arise on Intel hardware

    float2 f2MinMaxCosSunViewAngle = cosViewZenith*cosSunZenith + float2(-D, +D);
    // Clamp to allowable range
    cosViewSun    = clamp(cosViewSun, f2MinMaxCosSunViewAngle.x, f2MinMaxCosSunViewAngle.y);
}

void GetScatteringComputeParams2(
  float4 coord,
  out float height,
  out float cosViewZenith,
  out float cosSunZenith,
  out float cosViewSun)
{
  coord.xyzw = (coord - 0.5 / lutSize) / (1.0 - 1.0 / lutSize);
  
  height = lerp(HEIGHT_MARGIN, atmosphereTopHeight - HEIGHT_MARGIN, coord.x);
  
  cosViewZenith = coord.y * 2.0 - 1.0;
  
  cosSunZenith = coord.z * 2.0 - 1.0;
  
  cosViewSun = coord.w * 2.0 - 1.0;
  
  cosViewZenith = clamp(cosViewZenith, -1, 1);
  cosSunZenith = clamp(cosSunZenith, -1, 1);
  cosViewSun = clamp(cosViewSun, -1, 1);
  
  float D = (1.0 - cosViewZenith * cosViewZenith) * (1.0 - cosSunZenith  * cosSunZenith);
    
    // !!!!  IMPORTANT NOTE regarding NVIDIA hardware !!!!

    // There is a very weird issue on NVIDIA hardware with clamp(), saturate() and min()/max() 
    // functions. No matter what function is used, fCosViewZenithAngle and fCosSunZenithAngle
    // can slightly fall outside [-1,+1] range causing D to be negative
    // Using saturate(D), max(D, 0) and even D>0?D:0 does not work!
    // The only way to avoid taking the square root of negative value and obtaining NaN is 
    // to use max() with small positive value:
    D = sqrt( max(D, 1e-20) );
    
    // The issue was reproduceable on NV GTX 680, driver version 9.18.13.2723 (9/12/2013).
    // The problem does not arise on Intel hardware

    float2 f2MinMaxCosSunViewAngle = cosViewZenith*cosSunZenith + float2(-D, +D);
    // Clamp to allowable range
    cosViewSun    = clamp(cosViewSun, f2MinMaxCosSunViewAngle.x, f2MinMaxCosSunViewAngle.y);
  
}

void GetScatteringComputeParams3(
  float4 coord,
  out float height,
  out float cosViewZenith,
  out float cosSunZenith,
  out float cosViewSun)
{
  coord.xzw = (coord.xzw - 0.5 / lutSize.xzw) / (1.0 - 1.0/lutSize.xzw);
  
  coord.x = pow(coord.x, 1.0 / HEIGHT_POWER);
  height = lerp(HEIGHT_MARGIN, atmosphereTopHeight - HEIGHT_MARGIN, coord.x);
  
  float Rg = earthRadius;
  float Rt = earthRadius + atmosphereTopHeight;
  float r = height + Rg;
  if(coord.y < 0.5)
  {
    coord.y = ((0.5 - 0.5/lutSize.y) - coord.y) / (0.5 - 1.0 / lutSize.y);
    float dMin = height;
    float dMax = sqrt(r * r - Rg * Rg);
    float d = clamp(coord.y * dMax, dMin * 1.001, dMax * 0.999);
    cosViewZenith = (Rg * Rg - r * r - d * d) / (2.0 * r * d);
    cosViewZenith = min(cosViewZenith, -sqrt(1.0 - (Rg / r) * (Rg / r)) - 0.001);
  }
  else
  {
    coord.y = (coord.y - (0.5 + 0.5 / lutSize.y)) / (0.5 - 1.0 / lutSize.y);
    float dMin = Rt - r;
    float dMax = sqrt(r * r - Rg * Rg) + sqrt(Rt * Rt - Rg * Rg);
    float d = clamp(coord.y * dMax, dMin * 1.001, dMax * 0.999);
    cosViewZenith = (Rt * Rt - r * r - d * d) / (2.0 * r * d);
  }
  cosViewZenith = clamp(cosViewZenith, -1, 1);
  
  cosSunZenith = tan((2.0 * coord.z - 1.0 + 0.26) * 1.1) / tan(1.26 * 1.1);
  
  cosSunZenith = clamp(cosSunZenith, -1, 1);
  
  cosViewSun = 2.0 * coord.w - 1.0;
 
  cosViewSun = clamp(cosViewSun, -1, 1);
  
  
  float D = (1.0 - cosViewZenith * cosViewZenith) * (1.0 - cosSunZenith  * cosSunZenith);
    
    // !!!!  IMPORTANT NOTE regarding NVIDIA hardware !!!!

    // There is a very weird issue on NVIDIA hardware with clamp(), saturate() and min()/max() 
    // functions. No matter what function is used, fCosViewZenithAngle and fCosSunZenithAngle
    // can slightly fall outside [-1,+1] range causing D to be negative
    // Using saturate(D), max(D, 0) and even D>0?D:0 does not work!
    // The only way to avoid taking the square root of negative value and obtaining NaN is 
    // to use max() with small positive value:
    D = sqrt( max(D, 1e-20) );
    
    // The issue was reproduceable on NV GTX 680, driver version 9.18.13.2723 (9/12/2013).
    // The problem does not arise on Intel hardware

    float2 f2MinMaxCosSunViewAngle = cosViewZenith*cosSunZenith + float2(-D, +D);
    // Clamp to allowable range
    cosViewSun    = clamp(cosViewSun, f2MinMaxCosSunViewAngle.x, f2MinMaxCosSunViewAngle.y);
}



float4 GetScatteringLUTCoord1(
  float height,
  float cosViewZenith,
  float cosSunZenith,
  float cosViewSun)
{
  float4 coord;
  
  height = clamp(height, HEIGHT_MARGIN, atmosphereTopHeight - HEIGHT_MARGIN);
  coord.x = saturate( (height - HEIGHT_MARGIN) / (atmosphereTopHeight - HEIGHT_MARGIN * 2) );
  coord.x = pow(coord.x, HEIGHT_POWER);
  coord.x = lerp(0.5/lutSize.x, 1.0 - 0.5/lutSize.x, coord.x);
  
  //coord.y = cosViewZenith * 0.5 + 0.5;
  
  
  float r = earthRadius + height;
  float cosHorizon = -sqrt(r * r - earthRadius * earthRadius) / r;
  if(cosViewZenith > cosHorizon)
  {
    coord.y = saturate( (cosViewZenith - cosHorizon) / (1.0 - cosHorizon) );
    coord.y = pow(coord.y, VIEW_ZENITH_POWER);
    coord.y = 0.5 + 0.5/lutSize.y + coord.y * (0.5 - 1.0/lutSize.y);
  }
  else
  {
    coord.y = saturate( (cosHorizon - cosViewZenith) / (cosHorizon + 1.0) );
    coord.y = pow(coord.y, VIEW_ZENITH_POWER);
    coord.y = 0.5/lutSize.y + coord.y * (0.5 - 1.0/lutSize.y);
  }
  
  
  //coord.z = cosSunZenith * 0.5 + 0.5;
  
  coord.z = (atan(max(cosSunZenith, -0.1975) * tan(1.26 * 1.1)) / 1.1 + (1.0 - 0.26)) * 0.5;
  coord.z = lerp(0.5/lutSize.z, 1.0 - 0.5/lutSize.z, coord.z);
  
  
  coord.w = acos(clamp(cosViewSun, -1.0, 1.0)) / PI;
  coord.w = sign(coord.w - 0.5) * pow( abs(coord.w - 0.5) * 2.0, VIEW_SUN_POWER ) * 0.5 + 0.5;
  coord.w = lerp(0.5/lutSize.w, 1.0 - 0.5/lutSize.w, coord.w);
  
  return coord;
}

float4 GetScatteringLUTCoord2(
  float height,
  float cosViewZenith,
  float cosSunZenith,
  float cosViewSun)
{
  float4 coord;
  
  height = clamp(height, HEIGHT_MARGIN, atmosphereTopHeight - HEIGHT_MARGIN);
  coord.x = saturate( (height - HEIGHT_MARGIN) / (atmosphereTopHeight - HEIGHT_MARGIN * 2) );
  
  coord.y = cosViewZenith * 0.5 + 0.5;
  
  coord.z = cosSunZenith * 0.5 + 0.5;
  
  coord.w = cosViewSun * 0.5 + 0.5;
  
  coord = lerp(0.5/lutSize, 1.0 - 0.5/lutSize, coord);
  
  return coord;
}

float4 GetScatteringLUTCoord3(
  float height,
  float cosViewZenith,
  float cosSunZenith,
  float cosViewSun)
{
  float4 coord;
  
  height = clamp(height, HEIGHT_MARGIN, atmosphereTopHeight - HEIGHT_MARGIN);
  coord.x = saturate( (height - HEIGHT_MARGIN) / (atmosphereTopHeight - HEIGHT_MARGIN * 2) );
  coord.x = pow(coord.x, HEIGHT_POWER);
  coord.x = lerp(0.5/lutSize.x, 1.0 - 0.5/lutSize.x, coord.x);
  
  float Rg = earthRadius;
  float Rt = earthRadius + atmosphereTopHeight;
  float r = height + Rg;
  float H = sqrt(Rt * Rt - Rg * Rg);
  float rho = sqrt(r * r - Rg * Rg);
  float rmu = r * cosViewZenith;
  float delta = rmu * rmu - r * r + Rg * Rg;
  float4 cst;
  if(rmu < 0.0 && delta > 0.0)
    cst = float4(1.0, 0.0, 0.0, 0.5 - 0.5 / float(lutSize.y));
  else
    cst = float4(-1.0, H * H, H, 0.5 + 0.5 / float(lutSize.y));
	//float uR = 0.5 / float(RES_R) + rho / H * (1.0 - 1.0 / float(RES_R));
  coord.y = cst.w + (rmu * cst.x + sqrt(delta + cst.y)) / (rho + cst.z) * (0.5 - 1.0 / float(lutSize.y));
  
  coord.z = 0.5 / float(lutSize.z) + (atan(max(cosSunZenith, -0.1975) * tan(1.26 * 1.1)) / 1.1 + (1.0 - 0.26)) * 0.5 * (1.0 - 1.0 / float(lutSize.z));
  
  coord.w = cosViewSun * 0.5 + 0.5;
  coord.w = lerp(0.5/lutSize.w, 1.0 - 0.5/lutSize.w, coord.w);
  
  return coord;
}

#define GetScatteringComputeParams GetScatteringComputeParams1
#define GetScatteringLUTCoord GetScatteringLUTCoord1

void LUTCoordToTexCoord(
  float4 lutCoord,
  out float3 texCoord0,
  out float3 texCoord1,
  out float weight)
{
  float wSlice0 = floor(lutCoord.w * lutSize.w - 0.5);
  wSlice0 = clamp(wSlice0, 0, lutSize.w - 1);
  weight = lutCoord.w * lutSize.w - 0.5 - wSlice0;
  weight = clamp(weight, 0, 1);
  
  float2 wSlice0MinMaxZ = float2(wSlice0, wSlice0 + 1) / lutSize.w + float2(0.5, -0.5) / (lutSize.z * lutSize.w);
  float zCoord0 = clamp( (wSlice0 + lutCoord.z) / lutSize.w, wSlice0MinMaxZ.x, wSlice0MinMaxZ.y );
  
  //float depthSlice1 = (min(wSlice0 + 1, lutSize.w - 1) + lutCoord.z) / lutSize.w;
  float zCoordOffset = (min(wSlice0 + 1, lutSize.w - 1) - wSlice0) / lutSize.w;
  
  texCoord0 = float3(lutCoord.xy, zCoord0);
  texCoord1 = float3(lutCoord.xy, zCoord0 + zCoordOffset);
}

float3 ComputeLightDir(float cosSunZenith, float cosViewSun, float3 viewDir)
{
  float3 lightDir;
  if( abs(cosSunZenith) > 1-1e-7)
  {
    lightDir = float3(0.0f, sign(cosSunZenith), 0.0f);
  }
  else
  {
    lightDir.y = cosSunZenith;
    lightDir.z = viewDir.z > 0 ? (cosViewSun - viewDir.y * cosSunZenith) / viewDir.z : 0.0f;
    lightDir.x = sqrt( saturate(1.0 - dot(lightDir.yz, lightDir.yz)) );
    //if( abs(cosViewSun) > 1-1e-7)
    //  lightDir = viewDir * sign(cosViewSun);
  }
  
  return lightDir;
}

float3 ComputeInScattering(float height, float cosViewZenith, float cosSunZenith, float cosViewSun)
{
  float4 lutCoord = GetScatteringLUTCoord(height, cosViewZenith, cosSunZenith, cosViewSun);

  float3 texCoord0, texCoord1;
  float weight;
  LUTCoordToTexCoord(lutCoord, texCoord0, texCoord1, weight);
  
  float3 inScatteringR0 = inScatteringLUTR.SampleLevel(samplerLinearClamp, texCoord0, 0).xyz;
  float3 inScatteringR1 = inScatteringLUTR.SampleLevel(samplerLinearClamp, texCoord1, 0).xyz;
  
  float3 inScatteringR = lerp(inScatteringR0, inScatteringR1, weight);
  
  float3 inScatteringM0 = inScatteringLUTM.SampleLevel(samplerLinearClamp, texCoord0, 0).xyz;
  float3 inScatteringM1 = inScatteringLUTM.SampleLevel(samplerLinearClamp, texCoord1, 0).xyz;
  
  float3 inScatteringM = lerp(inScatteringM0, inScatteringM1, weight);
  
  float phaseR = PhaseFunction_R(cosViewSun);
  float phaseM = PhaseFunction_M(phaseG_M, cosViewSun);
  
  return inScatteringR * phaseR + inScatteringM * phaseM;
}

float3 ComputeInScattering(float3 pos, float3 viewDir, float3 lightDir)
{
  float3 earthToSampleDir = pos - earthCenter;
  float earthToSampleLen = length(earthToSampleDir);
  earthToSampleDir /= earthToSampleLen;
  
  float height = earthToSampleLen - earthRadius;
  float cosViewZenith = dot(earthToSampleDir, viewDir);
  float cosSunZenith = dot(earthToSampleDir, lightDir);
  float cosViewSun = dot(lightDir, viewDir);
  
  return ComputeInScattering(height, cosViewZenith, cosSunZenith, cosViewSun);
}
    
    ]]>
  </shader>

  <variable type="cbuffer" name="cb_screen">
    <variable type="float4" name="screenSize"/>
  </variable>

  <variable type="cbuffer" name="cb_initOpticalDepthLUT">
    <variable type="float" name="earthRadius"/>
    <variable type="float" name="atmosphereTopHeight"/>
    <variable type="float2" name="particleScaleHeight"/>
  </variable>

  <shader>
    <![CDATA[

#define OPTICALDEPTH_LUT_NUM_STEPS 256
    
float2 InitOpticalDepthLUTPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float heightScale = (vsOut.pos.x - 0.5f) / (screenSize.x - 1.0f);
  float startHeight = lerp(0.0f, atmosphereTopHeight, heightScale);
  startHeight = clamp(startHeight, 10.0f, atmosphereTopHeight - 10.0f);
  
  float3 startPos = float3(0.0f, startHeight, 0.0f);
  float cosTheta = (vsOut.pos.y - 0.5f) / (screenSize.y - 1.0f) * 2.0f - 1.0f;
  float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
  float3 rayDir = float3(0.0f, cosTheta, sinTheta);
  
  float3 earthCenter = float3(0.0f, -earthRadius, 0.0f);

  //Check earth intersecton
  float2 earthIntersection;
  GetRaySphereIntersection(startPos, rayDir, earthCenter, earthRadius, earthIntersection);
  if( earthIntersection.x > 0 )
    return 1e+20;
  
  float2 atmosphereTopIntersection;
  GetRaySphereIntersection(startPos, rayDir, earthCenter, earthRadius + atmosphereTopHeight, atmosphereTopIntersection);
  float3 endPos = startPos + rayDir * atmosphereTopIntersection.y;
  
  //Intergration
  float3 step = (endPos - startPos) / OPTICALDEPTH_LUT_NUM_STEPS;
  float stepLen = length(step);
  float2 preDensity = exp(-startHeight / particleScaleHeight);
  
  float2 densityAccum = 0.0f;
  float3 curPos = startPos + step;
  for(int i = 1; i <= OPTICALDEPTH_LUT_NUM_STEPS; ++i, curPos += step)
  {
    float height = length(earthCenter - curPos) - earthRadius;
    float2 density = exp(-height / particleScaleHeight);
    density = 0.5f * (preDensity + density);
    densityAccum += density * stepLen;
    preDensity = density;
  }
  
  return densityAccum;
}

    ]]>
  </shader>

  <technique name="InitOpticalDepthLUT">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="InitOpticalDepthLUTPS"/>
    </pass>
  </technique>


  

  <shader>
    <![CDATA[
    
#define SCATTERING_LUT_NUM_STEPS 256
    
void PreComputeSingleScatteringPS(
  PostProcessVSOut vsOut,
  out float3 outColor0 : SV_TARGET0,
  out float3 outColor1 : SV_TARGET1)
{
  float4 coord = float4(vsOut.tex.xy, wqCoord);
  float height, cosViewZenith, cosSunZenith, cosViewSun;
  GetScatteringComputeParams(coord, height, cosViewZenith, cosSunZenith, cosViewSun);
  
  float3 startPos = float3(0.0f, height, 0.0f);
  float3 rayDir = float3(0.0f, cosViewZenith, sqrt(1.0f - cosViewZenith * cosViewZenith));
  float3 earthCenter = float3(0.0f, -earthRadius, 0.0f);
  float3 lightDir = ComputeLightDir(cosSunZenith, cosViewSun, rayDir);
  //lightDir.y = cosSunZenith;
  //lightDir.z = rayDir.z > 0 ? (cosViewSun - rayDir.y * cosSunZenith) / rayDir.z : 0.0f;
  //lightDir.x = sqrt( 1.0 - dot(lightDir.yz, lightDir.yz) );
  
  float2 atmIntersection, earthIntersection;
  GetRaySphereIntersection(startPos, rayDir, earthCenter, earthRadius + atmosphereTopHeight, atmIntersection);
  GetRaySphereIntersection(startPos, rayDir, earthCenter, earthRadius - 1e2, earthIntersection);
  
  float endDist = atmIntersection.y;
  if(earthIntersection.x > 0)
    endDist = min(earthIntersection.x, endDist);
  
  float3 endPos = startPos + rayDir * endDist;
  
  float3 step = (endPos - startPos) / SCATTERING_LUT_NUM_STEPS;
  float stepLen = length(step);
  
  float phaseR = PhaseFunction_R(cosViewSun);
  float phaseM = PhaseFunction_M(phaseG_M, cosViewSun);
  
  float2 densityToCameraAccum = 0.0f;
  
  float3 inScatteingR = 0.0f;
  float3 inScatteingM = 0.0f;
  
  float3 p = startPos;
  for(int i = 0; i < SCATTERING_LUT_NUM_STEPS; ++i, p += step)
  {
    float3 earthToSampleDir = p - earthCenter;
    float r = length(earthToSampleDir);
    earthToSampleDir /= r;
    
    float sampleHeight = clamp(r - earthRadius, 10.0f, atmosphereTopHeight - 10.0f);
    float3 attenuationToSample = ComputeAttenuation(sampleHeight, dot(earthToSampleDir, lightDir));
    
    float2 densitySample = exp( -sampleHeight / particleScaleHeight );
    densityToCameraAccum += densitySample * stepLen;
    
    float3 attenuationToCamera = exp(- (attenuationR * densityToCameraAccum.x + attenuationM * densityToCameraAccum.y) );
    
    float3 attenuation = attenuationToSample * attenuationToCamera * stepLen;
    
    inScatteingR += attenuation * scatteringR * densitySample.x;
    inScatteingM += attenuation * scatteringM * densitySample.y;
  }
  
  //return inScatteingR * phaseR + inScatteingM * phaseM);
  //return 1.0f;
  outColor0 = inScatteingR;// * phaseR + inScatteingM * phaseM;
  outColor1 = inScatteingM;
  
  //if( any(isnan(outColor0)) )
  //  outColor0 = float3(1.0f, 0.0f, 0.0f);
  //if( any(isnan(outColor1)) )
  //  outColor1 = float3(1.0f, 0.0f, 0.0f);
}
    
    ]]>
  </shader>
  
  <technique name="PreComputeSingleScattering">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="PreComputeSingleScatteringPS"/>
    </pass>
  </technique>

  
  <shader>
    <![CDATA[
  
#define NUM_SPHERICAL_SAMPLES 256
  
void ComputeOutRadiancePS(
  PostProcessVSOut vsOut,
  out float3 outColor0 : SV_TARGET0,
  out float3 outColor1 : SV_TARGET1)
{
  float4 coord = float4(vsOut.tex.xy, wqCoord);
  float height, cosViewZenith, cosSunZenith, cosViewSun;
  GetScatteringComputeParams(coord, height, cosViewZenith, cosSunZenith, cosViewSun);
  
  float3 pos = float3(0.0f, height, 0.0f);
  float3 viewDir = float3( 0.0f, cosViewZenith, sqrt(1.0 - cosViewZenith * cosViewZenith) );
  float3 lightDir = ComputeLightDir(cosSunZenith, cosViewSun, viewDir);

  float3 outRadianceR = 0.0f;
  float3 outRadianceM = 0.0f;
  for(int i = 0; i < NUM_SPHERICAL_SAMPLES; ++i)
  {
    float2 sample2D = Hammersley2d(uint(i), NUM_SPHERICAL_SAMPLES);
    float cosTheta = sample2D.x * 2.0 - 1.0;
    float sinTheta = sqrt(1 - cosTheta * cosTheta);
    float phi = 2 * PI * sample2D.y;
    
    float3 sampleDir = float3(sinTheta * sin(phi), cosTheta, sinTheta * cos(phi));
    float3 inScattering = ComputeInScattering(pos, sampleDir, lightDir);
    if(any(isnan(inScattering)))
      inScattering = float3(0.0f, 1.0f, 0.0f);
    
    float phaseR = PhaseFunction_R(dot(sampleDir, viewDir));
    float phaseM = PhaseFunction_M(phaseG_M, dot(sampleDir, viewDir));
    
    outRadianceR += inScattering * phaseR;
    outRadianceM += inScattering * phaseM;
  }
  
  outColor0 = outRadianceR * scatteringR * 4 * PI / NUM_SPHERICAL_SAMPLES;
  outColor1 = outRadianceM * scatteringM * 4 * PI / NUM_SPHERICAL_SAMPLES;
}
  
    ]]>
  </shader>
  
  <technique name="ComputeOutRadiance">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ComputeOutRadiancePS"/>
    </pass>
  </technique>

  <shader>
    <![CDATA[
  
void PreComputeScatteringOrderPS(
  PostProcessVSOut vsOut,
  out float3 outColor0 : SV_TARGET0,
  out float3 outColor1 : SV_TARGET1)
{
  float4 coord = float4(vsOut.tex.xy, wqCoord);
  float height, cosViewZenith, cosSunZenith, cosViewSun;
  GetScatteringComputeParams(coord, height, cosViewZenith, cosSunZenith, cosViewSun);
  
  float3 startPos = float3(0.0f, height, 0.0f);
  float3 rayDir = float3(0.0f, cosViewZenith, sqrt(1.0f - cosViewZenith * cosViewZenith));
  float3 earthCenter = float3(0.0f, -earthRadius, 0.0f);
  float3 lightDir = ComputeLightDir(cosSunZenith, cosViewSun, rayDir);
  //lightDir.y = cosSunZenith;
  //lightDir.z = rayDir.z > 0 ? (cosViewSun - rayDir.y * cosSunZenith) / rayDir.z : 0.0f;
  //lightDir.x = sqrt( saturate(1.0 - dot(lightDir.yz, lightDir.yz)) );
  
  float2 atmIntersection, earthIntersection;
  GetRaySphereIntersection(startPos, rayDir, earthCenter, earthRadius + atmosphereTopHeight, atmIntersection);
  GetRaySphereIntersection(startPos, rayDir, earthCenter, earthRadius - 1e2, earthIntersection);
  
  float endDist = atmIntersection.y;
  if(earthIntersection.x > 0)
    endDist = min(earthIntersection.x, endDist);
  
  float3 endPos = startPos + rayDir * endDist;
  
  float3 step = (endPos - startPos) / SCATTERING_LUT_NUM_STEPS;
  float stepLen = length(step);
  
  float phaseR = PhaseFunction_R(cosViewSun);
  float phaseM = PhaseFunction_M(phaseG_M, cosViewSun);
  
  float2 densityToCameraAccum = 0.0f;
  
  float3 inScatteingR = 0.0f;
  float3 inScatteingM = 0.0f;
  
  float3 p = startPos;
  for(int i = 0; i < SCATTERING_LUT_NUM_STEPS; ++i, p += step)
  {
    float3 earthToSampleDir = p - earthCenter;
    float r = length(earthToSampleDir);
    earthToSampleDir /= r;
    
    float sampleHeight = clamp(r - earthRadius, 10.0f, atmosphereTopHeight - 10.0f);
    float3 attenuationToSample = ComputeAttenuation(sampleHeight, dot(earthToSampleDir, lightDir));
    
    float cosViewSample = dot(earthToSampleDir, -rayDir);
    float cosSunSample = dot(earthToSampleDir, lightDir);
    float cosViewSunSample = dot(-rayDir, lightDir);
    
    float4 lutCoord = GetScatteringLUTCoord(sampleHeight, cosViewSample, cosSunSample, cosViewSunSample);

    float3 texCoord0, texCoord1;
    float weight;
    LUTCoordToTexCoord(lutCoord, texCoord0, texCoord1, weight);
  
    float3 inScatteringR0 = inScatteringLUTR.SampleLevel(samplerLinearClamp, texCoord0, 0).xyz;
    float3 inScatteringR1 = inScatteringLUTR.SampleLevel(samplerLinearClamp, texCoord1, 0).xyz;
  
    float3 inScatteringR = lerp(inScatteringR0, inScatteringR1, weight);
  
    float3 inScatteringM0 = inScatteringLUTM.SampleLevel(samplerLinearClamp, texCoord0, 0).xyz;
    float3 inScatteringM1 = inScatteringLUTM.SampleLevel(samplerLinearClamp, texCoord1, 0).xyz;
  
    float3 inScatteringM = lerp(inScatteringM0, inScatteringM1, weight);
    
    float3 radiance = inScatteringR + inScatteringM;
    //float3 radiance = ComputeInScattering(sampleHeight, cosViewSample, cosSunSample, cosViewSun);
    
    float2 densitySample = exp( -sampleHeight / particleScaleHeight );
    densityToCameraAccum += densitySample * stepLen;
    
    float3 attenuationToCamera = exp(- (attenuationR * densityToCameraAccum.x + attenuationM * densityToCameraAccum.y) );
    
    float3 attenuation = attenuationToSample * attenuationToCamera * stepLen;
    
    inScatteingR += radiance * stepLen * attenuationToCamera * densitySample.x;
    inScatteingM += radiance * stepLen * attenuationToCamera * densitySample.y;
  }
  
  outColor0 = inScatteingR;
  outColor1 = inScatteingM;
}
  
    ]]>
  </shader>

  <technique name="PreComputeScatteringOrder">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="PreComputeScatteringOrderPS"/>
    </pass>
  </technique>

  <shader>
    <![CDATA[
    
void AddScatteringPS(
  PostProcessVSOut vsOut,
  out float3 outColor0 : SV_TARGET0,
  out float3 outColor1 : SV_TARGET1)
{
  outColor0 = inScatteringLUTR.Load(uint4(vsOut.pos.xy, depthSlice, 0)).xyz;
  outColor1 = inScatteringLUTM.Load(uint4(vsOut.pos.xy, depthSlice, 0)).xyz;
}
    
    ]]>
  </shader>

  <variable type='BlendState' name='srcOne_dstOne_Add'>
    <state name="blendRTDesc" index="0">
      <state name="blendEnable" value="true"/>
      <state name="srcBlend" value="ONE"/>
      <state name="dstBlend" value="ONE"/>
      <state name="blendOP" value="ADD"/>
    </state>
    <state name="blendRTDesc" index="1">
      <state name="blendEnable" value="true"/>
      <state name="srcBlend" value="ONE"/>
      <state name="dstBlend" value="ONE"/>
      <state name="blendOP" value="ADD"/>
    </state>
  </variable>

  <technique name="AddScattering">
    <pass>
      <state value="disableDepth"/>
      <state value="srcOne_dstOne_Add"/>
      <vs entry="PostProcessVS"/>
      <ps entry="AddScatteringPS"/>
    </pass>
  </technique>

  
  <shader>
    <![CDATA[
    
void AddSingleScatteringPS(
  PostProcessVSOut vsOut,
  out float3 outColor0 : SV_TARGET0)
{
  float4 coord = float4(vsOut.tex.xy, wqCoord);
  float height, cosViewZenith, cosSunZenith, cosViewSun;
  GetScatteringComputeParams(coord, height, cosViewZenith, cosSunZenith, cosViewSun);
  
  float phaseR = PhaseFunction_R(cosViewSun);

  float3 multiScatteringR = inScatteringLUTR.Load(uint4(vsOut.pos.xy, depthSlice, 0)).xyz;
  float3 multiScatteringM = inScatteringLUTM.Load(uint4(vsOut.pos.xy, depthSlice, 0)).xyz;
  
  outColor0 = (multiScatteringR + multiScatteringM) / phaseR;
}
    
    ]]>
  </shader>

  <technique name="AddSingleScattering">
    <pass>
      <state value="disableDepth"/>
      <state value="srcOne_dstOne_Add"/>
      <vs entry="PostProcessVS"/>
      <ps entry="AddSingleScatteringPS"/>
    </pass>
  </technique>
  

  <variable type="cbuffer" name="cb_initSampleLines">
    <variable type="float2" name="lightPosH"/>
    <variable type="uint" name="bLightInScreen"/>
    <variable type="float" name="_pad_initSampleLines"/>
  </variable>
  
  <shader>
    <![CDATA[

//#define NUM_SAMPLELINES 1024
//#define MAX_SAMPLES_PERLINE 1024

bool IsInScreen(float2 pos)
{
  static const float epison = 0.2;
  return all( abs(pos) <= 1.0 - (1.0 - epison) * screenSize.zw );
}

float4 InitSampleLinesPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float lineIndex = (vsOut.pos.x - 0.5) / NUM_SAMPLELINES;
  uint boundIndex = clamp(floor(lineIndex * 4.0), 0, 3);
  float boundFrac = frac(lineIndex * 4.0);
  
  bool4 boundMask = (boundIndex.xxxx == uint4(0, 1, 2, 3));
  
  float4 bounds = float4(-1.0f, -1.0f, 1.0f, 1.0f) + screenSize.zwzw * float4(1.0, 1.0, -1.0, -1.0);
  bool4 bInvalidBound = ( (lightPosH.xyxy - bounds) * float4(1.0, 1.0, -1.0, -1.0) <= 0 );
  //Check invalid
  if( dot(bInvalidBound, boundMask) )
    return -100.0;
  
  float4 boundPosX = float4(              0, boundFrac,         1, 1.0 - boundFrac);
  float4 boundPosY = float4(1.0 - boundFrac,         0, boundFrac,               1);
  float2 boundPosFrac = float2(dot(boundPosX, boundMask), dot(boundPosY, boundMask));
  float2 endPos = lerp(bounds.xy, bounds.zw, boundPosFrac);
  
  float2 startPos;
  if(bLightInScreen)
  {
    startPos = lightPosH;
  }
  else
  {
    float2 rayDir = endPos - lightPosH;
    float rayLen = length(rayDir);
    rayDir /= max(0.0001f, rayLen);
    
    bool4 bValidIntersectMask = abs(rayDir.xyxy) > 1e-5;
    float4 distToBournds = (bounds - lightPosH.xyxy) / (rayDir.xyxy + !bValidIntersectMask);
    bValidIntersectMask = bValidIntersectMask && (distToBournds < rayLen - 1e-4);
    distToBournds = distToBournds * bValidIntersectMask + !bValidIntersectMask * -FLT_MAX;
    
    float startPosDist = 0.0f;
    startPosDist = max(startPosDist, distToBournds.x);
    startPosDist = max(startPosDist, distToBournds.y);
    startPosDist = max(startPosDist, distToBournds.z);
    startPosDist = max(startPosDist, distToBournds.w);
    
    startPos = lightPosH + rayDir * startPosDist;
  }
  
  //Advance EndPos
  if( IsInScreen(startPos) )
  {
    float lineScreenDist = length( (endPos - startPos) * 0.5f * screenSize.xy );
    endPos = endPos + (endPos - startPos) * max(1.0, (float)MAX_SAMPLES_PERLINE / lineScreenDist);
  }
  
  return float4(startPos, endPos);
}
    
    ]]>
  </shader>

  <technique name="InitSampleLines">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="InitSampleLinesPS"/>
    </pass>
  </technique>


  <variable type="Texture2D" name="sampleLinesTex"/>
  <variable type="Texture2D" name="linearDepthTex"/>
  
  <shader>
    <![CDATA[
    
void InitSampleCoordsPS(
  PostProcessVSOut vsOut,
  out float2 sampleCoord : SV_TARGET0,
  out float  cameraZ : SV_TARGET1)
{
  float4 lineStartEnd = sampleLinesTex.Load(uint3(vsOut.pos.y, 0, 0));
  
  if( !IsInScreen(lineStartEnd.xy) )
    discard;
  
  sampleCoord = lerp(lineStartEnd.xy, lineStartEnd.zw, (vsOut.pos.x - 0.5) / (float)(MAX_SAMPLES_PERLINE - 1) );
  
  if( !IsInScreen(sampleCoord) )
    discard;
  
  float2 sampleUV = sampleCoord * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);
  
  cameraZ = linearDepthTex.SampleLevel(samplerLinearClamp, sampleUV, 0).x;
}
    
    ]]>
  </shader>

  <variable type="DepthStencilState" name="noDepth_StencilIncr">
    <state name="depthEnable" value="false"/>
    <state name="stencilEnable" value="true"/>
    <state name="frontFace">
      <state name="stencilPassOp" value="INCR"/>
      <state name="stencilFunc" value="ALWAYS"/>
    </state>
  </variable>

  <technique name="InitSampleCoords">
    <pass>
      <state value="noDepth_StencilIncr"/>
      <vs entry="PostProcessVS"/>
      <ps entry="InitSampleCoordsPS"/>
    </pass>
  </technique>

  
  <variable type="Texture2D" format="uint2" name="interpolationSourceTex"/>

  <shader>
    <![CDATA[
    
void MarkRayMarchingSamplesPS(PostProcessVSOut vsOut)
{
  uint2 interpolationSource = interpolationSourceTex.Load(uint3(vsOut.pos.xy, 0));
  if(interpolationSource.x != interpolationSource.y)
    discard;
}
    
    ]]>
  </shader>

  <variable type="DepthStencilState" name="noDepth_StencilEqualIncr">
    <state name="depthEnable" value="false"/>
    <state name="stencilEnable" value="true"/>
    <state name="frontFace">
      <state name="stencilPassOp" value="INCR"/>
      <state name="stencilFunc" value="EQUAL"/>
    </state>
    <state name="stencilRef" value="1"/>
  </variable>

  <technique name="MarkRayMarchingSamples">
    <pass>
      <state value="noDepth_StencilEqualIncr"/>
      <vs entry="PostProcessVS"/>
      <ps entry="MarkRayMarchingSamplesPS"/>
    </pass>
  </technique>


  <variable type="Texture2D" name="sampleCoordsTex"/>
  <variable type="Texture2D" name="cameraDepthTex"/>


  <variable type="cbuffer" name="cb_rayMarching">
    <variable type="float4x4" name="proj"/>
    <variable type="float4x4" name="view"/>
    <variable type="float4x4" name="invView"/>
    <variable type="float3" name="lightRadiance"/>
    <variable type="float3" name="lightDirection"/>
    <variable type="float3" name="cameraPos"/>
    <variable type="float2" name="cameraNearFar"/>
    <variable type="float3" name="earthCenter"/>
    <variable type="float3" name="scatteringR"/>
    <variable type="float3" name="scatteringM"/>
    <variable type="float3" name="attenuationR"/>
    <variable type="float3" name="attenuationM"/>
    <variable type="float" name="phaseG_M"/>
  </variable>
  
  <shader>
    <![CDATA[

float3 GetWorldPos(
  float2 samplePos,
  float linearDepth,
  float2 camNearFar,
  float2 invScreenSize,
  float4x4 proj,
  float4x4 invView)
{
  float depthV = linearDepth * (camNearFar.y - camNearFar.x) + camNearFar.x;
  
  float2 xy_H = samplePos;
  float2 xy_V = xy_H * depthV / float2(proj[0][0], proj[1][1]);
  
  float3 posV = float3(xy_V, depthV);
  float3 posW = mul(float4(posV, 1.0f), invView).xyz;
  return posW;
}

float PhaseFunction_HG(float g, float cosTheta)
{
  float g2 = g * g;
  
  return (1 - g2) * 0.25 / ( PI * pow(abs(1 + g2 - (g + g) * cosTheta), 3.0/2.0) );
}




#define RAYMARCHING_NUM_SAMPLES 32

void RayMarchingPS(
  PostProcessVSOut vsOut,
  out float3 outLightAccum : SV_TARGET0,
  out float3 outAttenuation : SV_TARGET1)
{

  float2 sampleCoord = sampleCoordsTex.Load(uint3(vsOut.pos.xy, 0)).xy;
  float depth = cameraDepthTex.Load(uint3(vsOut.pos.xy, 0)).x;
  float3 posFromDepth = GetWorldPos(sampleCoord, depth, cameraNearFar, screenSize.zw, proj, invView);
  
  float3 cameraToDist = posFromDepth - cameraPos;
  float cameraToDepthDist = length(cameraToDist);
  
  float3 traceDir = cameraToDist / max(1e-5, cameraToDepthDist);
  
  float2 atmIntersection, earthIntersection;
  GetRaySphereIntersection(cameraPos, traceDir, earthCenter, earthRadius + atmosphereTopHeight, atmIntersection);
  GetRaySphereIntersection(cameraPos, traceDir, earthCenter, earthRadius - 1e4, earthIntersection);
  
  if(atmIntersection.y <= 0 )
  {
    outLightAccum = 0.0f;
    outAttenuation = 0.0f;
    return;
  }
  
  float3 startPos = 0.0f;
  float3 endPos = 0.0f;
  
  //Restrict start pos
  float startDist = max(atmIntersection.x, 0);
  startPos = cameraPos + traceDir * startDist;
  
  //Restrict end pos
  float endDist = cameraToDepthDist;
  if(depth >= 0.99f)
    endDist = FLT_MAX;
  endDist = min(atmIntersection.y, endDist);
  if( earthIntersection.x > 0 )
    endDist = min(earthIntersection.x, endDist);
  endPos = cameraPos + traceDir * endDist;
  
  float3 step = (endPos - startPos) / RAYMARCHING_NUM_SAMPLES;
  float stepLen = length(step);
  
  float3 p = startPos;
  
  float3 stepV = mul(float4(step, 0.0f), view).xyz;
  float viewDepthStep = stepV.z;
  float viewDepth = mul(float4(p, 1.0f), view).z;
  
  float viewDist = 0.0f;
  
  float2 densityToCameraAccum = 0.0f;
  
  float cosViewLight = dot( -lightDirection, traceDir);
  float phaseR = PhaseFunction_R(cosViewLight);
  float phaseM = PhaseFunction_M(phaseG_M, cosViewLight);
  
  float3 lightAccumR = 0.0f;
  float3 lightAccumM = 0.0f;
  
  [unroll] for(
    int stepIndex = 0;
    stepIndex < RAYMARCHING_NUM_SAMPLES;
    ++stepIndex, p += step, viewDist += stepLen, viewDepth += viewDepthStep)
  {
    //float shadow = ComputeShadow_DirectionalLight(shadowConfig.y, p, viewDepth);
    //if(viewDepth < cameraNearFar.x)
    //  shadow = 0.0f;
    float shadow = 1.0f;
    
    float3 earthToSampleDir = p - earthCenter;
    float earthToSampleLen = length(earthToSampleDir);
    earthToSampleDir /= earthToSampleLen;
    float height = earthToSampleLen - earthRadius;
    float cosLightZenith = dot(-earthToSampleDir, lightDirection);
    //float2 lutCoord = float2(height / atmosphereTopHeight, cosTheta * 0.5f + 0.5f);
    //float2 densityToSampleAccum = opticalDepthLUT.SampleLevel(samplerLinearClamp, lutCoord, 0).xy;
    
    //float3 attenuationToSample = exp(- (attenuationR * densityToSampleAccum.x + attenuationM * densityToSampleAccum.y) );
    float3 attenuationToSample = ComputeAttenuation(height, cosLightZenith);
    
    float2 densitySample = exp( -height / particleScaleHeight );
    densityToCameraAccum += densitySample * stepLen;
    
    float3 attenuationToCamera = exp(- (attenuationR * densityToCameraAccum.x + attenuationM * densityToCameraAccum.y) );
    //float3 attenuationToCamera = ComputeAttenuationPoints(p, startPos, earthCenter, earthRadius);
    
    float3 attenuation = attenuationToSample * attenuationToCamera * stepLen * shadow;
    
    lightAccumR += attenuation * scatteringR * densitySample.x;
    lightAccumM += attenuation * scatteringM * densitySample.y;
  }
  
  float3 lightAccum = lightRadiance * (lightAccumR * phaseR + lightAccumM * phaseM);
  //float3 attenuationAccum = exp(- (attenuationR * densityToCameraAccum.x + attenuationM * densityToCameraAccum.y) );
  float3 attenuationAccum = ComputeAttenuationPoints(endPos, startPos, earthCenter, earthRadius);
  
  float3 inScatteringStart = ComputeInScattering(startPos, traceDir, -lightDirection);
  if( depth < 0.99 )
  {
    inScatteringStart -= ComputeInScattering(posFromDepth, traceDir, -lightDirection);
    inScatteringStart = max(inScatteringStart, 0.0f);
  }
  
  
  outLightAccum = inScatteringStart * lightRadiance;
  //outLightAccum = inScattering * lightRadiance;
  //outLightAccum = lightAccum;
  outAttenuation = attenuationAccum;
}
    
    ]]>
  </shader>

  <variable type="DepthStencilState" name="noDepth_StencilEqual2">
    <state name="depthEnable" value="false"/>
    <state name="stencilEnable" value="true"/>
    <state name="frontFace">
      <state name="stencilFunc" value="EQUAL"/>
    </state>
    <state name="stencilRef" value="2"/>
  </variable>

  <technique name="RayMarching">
    <pass>
      <state value="noDepth_StencilEqual2"/>
      <!--<state value="disableDepth"/>-->
      <vs entry="PostProcessVS"/>
      <ps entry="RayMarchingPS"/>
    </pass>
  </technique>


  <variable type="Texture2D" name="lightAccumTex"/>
  <variable type="Texture2D" name="attenuationTex"/>

  <shader>
    <![CDATA[
    
void InterpolateRestSamplesPS(
  PostProcessVSOut vsOut,
  out float3 outLightAccum : SV_TARGET0,
  out float3 outAttenuation : SV_TARGET1 )
{
  uint2 sourceIndex = interpolationSourceTex.Load(uint3(vsOut.pos.xy, 0));
  float interpolationPos = (vsOut.pos.x - 0.5 - (float)sourceIndex.x) / max(1, sourceIndex.y - sourceIndex.x);
  
  /*
  float cameraDepth = cameraDepthTex.Load(uint3(vsOut.pos.xy, 0)).xyz;
  float cameraDepth0 = cameraDepthTex.Load(uint3(sourceIndex.x, vsOut.pos.y, 0)).xyz;
  float cameraDepth1 = cameraDepthTex.Load(uint3(sourceIndex.y, vsOut.pos.y, 0)).xyz;
  float2 depthWeight = 1.0f / max(1e-5, abs(cameraDepth - float2(cameraDepth0, cameraDepth1)) );
  
  float2 weights = depthWeight * float2(1.0f - interpolationPos, interpolationPos);
  float weightSum = dot(weights, 1);
  */
  
  float3 lightAccum0 = lightAccumTex.Load(uint3(sourceIndex.x, vsOut.pos.y, 0)).xyz;
  float3 lightAccum1 = lightAccumTex.Load(uint3(sourceIndex.y, vsOut.pos.y, 0)).xyz;
  outLightAccum = lerp(lightAccum0, lightAccum1, interpolationPos);
  //outLightAccum = (lightAccum0 * weights.x + lightAccum1 * weights.y) / max(1e-5, weightSum);
  
  float3 attenuation0 = attenuationTex.Load(uint3(sourceIndex.x, vsOut.pos.y, 0)).xyz;
  float3 attenuation1 = attenuationTex.Load(uint3(sourceIndex.y, vsOut.pos.y, 0)).xyz;
  outAttenuation = lerp(attenuation0, attenuation1, interpolationPos);
  //outAttenuation = (attenuation0 * weights.x + attenuation1 * weights.y) / max(1e-5, weightSum);
}
    
    ]]>
  </shader>

  <technique name="InterpolateRestSamples">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="InterpolateRestSamplesPS"/>
    </pass>
  </technique>

  
  <variable type="Texture2D" name="sceneTex"/>

  <shader>
    <![CDATA[
    
float4 UnWarpSamplesPS(PostProcessVSOut vsOut) : SV_TARGET
{
  float2 posH = vsOut.tex.xy * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f);
  float2 rayDir = normalize(posH - lightPosH);
  
  float cameraDepth = linearDepthTex.Load(uint3(vsOut.pos.xy, 0)).x;
  
  float4 bounds = float4(-1.0f, -1.0f, 1.0f, 1.0f) + screenSize.zwzw * float4(1.0, 1.0, -1.0, -1.0);
  float4 halfSapceEquationTerms = (posH.xxyy - bounds.xzyw) * rayDir.yyxx;
  bool4 halfSpaceFlags = halfSapceEquationTerms.xyyx < halfSapceEquationTerms.zzww;
  
  bool4 sectionFlags = halfSpaceFlags.wxyz && !halfSpaceFlags.xyzw;
  
  float4 distToBounds = (bounds - posH.xyxy) / ( rayDir.xyxy + (abs(rayDir.xyxy) < 1e-6) );
  float distToExitBound = dot(distToBounds, sectionFlags);
  float2 exitPoint = posH + rayDir * distToExitBound;
  
  float4 lineIndexPosMask = float4(0, 0.25, 0.5, 0.75) + abs(exitPoint.yxyx - bounds.wxyz) / (bounds.wzwz - bounds.yxyx) / 4.0f;
  float lineIndexPos = dot(lineIndexPosMask, sectionFlags);
  
  float leftLineIndex = min( floor(lineIndexPos * NUM_SAMPLELINES), NUM_SAMPLELINES-1 );
  
  float lineIndexCoord[2];
  lineIndexCoord[0] = (leftLineIndex + 0.5) / NUM_SAMPLELINES;
  lineIndexCoord[1] = frac( (leftLineIndex + 1.5) / NUM_SAMPLELINES );
  
  float lineWeights[2];
  lineWeights[1] = lineIndexPos * NUM_SAMPLELINES - leftLineIndex;
  lineWeights[0] = 1.0f - lineWeights[1];
  
  float3 lightAccum = 0.0f;
  float3 attenuation = 0.0f;
  float weightSum = 0.0f;
  
  for(int i = 0; i < 2; ++i)
  {
    float4 sampleLineStartEnd = sampleLinesTex.SampleLevel(samplerPointClamp, float2(lineIndexCoord[i], 0.5f), 0);
    
    float2 lineDir = sampleLineStartEnd.zw - sampleLineStartEnd.xy;
    float lineLen = length(lineDir);
    lineDir /= max(1e-6, lineLen);
    
    float projOnLine = dot(lineDir, posH - sampleLineStartEnd.xy) / max(1e-6, lineLen);
    projOnLine *= (float)MAX_SAMPLES_PERLINE - 1;
    
    float leftSampleIndex = floor(projOnLine);
    float leftSampleWeight = 1.0 - frac(projOnLine);
    
    float2 leftSampleUV = float2(leftSampleIndex / MAX_SAMPLES_PERLINE, lineIndexCoord[i]);
    float2 rightSampleUV = float2((leftSampleIndex + 1) / MAX_SAMPLES_PERLINE, lineIndexCoord[i]);
    
    float leftCameraDepth = cameraDepthTex.SampleLevel(samplerPointClamp, leftSampleUV, 0).x;
    float rightCameraDepth = cameraDepthTex.SampleLevel(samplerPointClamp, rightSampleUV, 0).x;
    float2 depthWeights = 1.0 / max(1e-4, abs( float2(leftCameraDepth, rightCameraDepth) - cameraDepth ));
    
    float2 weights = float2(leftSampleWeight, 1.0 - leftSampleWeight) * depthWeights * lineWeights[i];
    
    float3 leftLightAccum = lightAccumTex.SampleLevel(samplerPointClamp, leftSampleUV, 0).xyz;
    float3 rightLightAccum = lightAccumTex.SampleLevel(samplerPointClamp, rightSampleUV, 0).xyz;
    lightAccum += leftLightAccum * weights.x + rightLightAccum * weights.y;
    
    float3 leftAttenuation = attenuationTex.SampleLevel(samplerPointClamp, leftSampleUV, 0).xyz;
    float3 rightAttenuation = attenuationTex.SampleLevel(samplerPointClamp, rightSampleUV, 0).xyz;
    attenuation += leftAttenuation * weights.x + rightAttenuation * weights.y;
    
    weightSum += dot(weights, 1);
  }
  
  lightAccum /= max(1e-5, weightSum);
  attenuation /= max(1e-5, weightSum);
  
  float3 sceneColor = sceneTex.Load(uint3(vsOut.pos.xy, 0)).xyz;
  
  return float4(lightAccum + sceneColor * attenuation, 1.0f);
}
    
    ]]>
  </shader>

  <technique name="UnWarpSamples">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="UnWarpSamplesPS"/>
    </pass>
  </technique>


  <variable type="cbuffer" name="cb_renderSun">
    <variable type="float" name="sunRadius"/>
    <variable type="float3" name="sunRadiance"/>
  </variable>

  <shader>
    <![CDATA[
    
void RenderSunVS(
  uint vertexID : SV_VertexID,
  out float4 pos : SV_POSITION,
  out float2 posH : POSITION)
{
  float2 sunRadiusH = sunRadius * float2(proj[0][0], proj[1][1]);
  float4 sunMinMax = lightPosH.xyxy + sunRadiusH.xyxy * float4(-1.0f, -1.0f, 1.0f, 1.0f);
  
  float4 posMap[4] = 
  {
    float4(sunMinMax.xw, 0.0f, 1.0f),
    float4(sunMinMax.zw, 0.0f, 1.0f),
    float4(sunMinMax.xy, 0.0f, 1.0f),
    float4(sunMinMax.zy, 0.0f, 1.0f)
  };
  
  pos = posMap[vertexID];
  posH = pos.xy;
}

float4 RenderSunPS(
  float4 pos : SV_POSITION,
  float2 posH : POSITION) : SV_TARGET
{
  float2 sunRadiusH = sunRadius * float2(proj[0][0], proj[1][1]);
  float2 dist = (posH - lightPosH) / sunRadiusH;
  return float4(sunRadiance, saturate(1.0 - dot(dist, dist)));
}
    
    ]]>
  </shader>

  <variable type="DepthStencilState" name="noDepth_StencilEqual0">
    <state name="depthEnable" value="false"/>
    <state name="stencilEnable" value="true"/>
    <state name="frontFace">
      <state name="stencilFunc" value="EQUAL"/>
    </state>
    <state name="stencilRef" value="0"/>
  </variable>

  <variable type='BlendState' name='srcSAlpha_dstOne_Add'>
    <state name="blendRTDesc" index="0">
      <state name="blendEnable" value="true"/>
      <state name="srcBlend" value="SRC_ALPHA"/>
      <state name="dstBlend" value="ONE"/>
      <state name="dstBlendAlpha" value="ZERO"/>
    </state>
  </variable>

  <technique name="RenderSun">
    <pass>
      <state value="noDepth_StencilEqual0"/>
      <state value="srcSAlpha_dstOne_Add"/>
      <vs entry="RenderSunVS"/>
      <ps entry="RenderSunPS"/>
    </pass>
  </technique>


  <variable type="cbuffer" name="cb_computeSunRadiance">
    <variable type="float" name="computeSunRadianceHeight"/>
  </variable>

  <shader>
    <![CDATA[
    
float3 ComputeSunRadiancePS(PostProcessVSOut vsOut) : SV_TARGET
{
  float cosTheta = dot(float3(0.0f, -1.0f, 0.0f), lightDirection);
  float2 lutCoord = float2(computeSunRadianceHeight / atmosphereTopHeight, cosTheta * 0.5f + 0.5f);
  float2 densityToSampleAccum = opticalDepthLUT.SampleLevel(samplerLinearClamp, lutCoord, 0).xy;
  
  float3 attenuationToSample = exp(- (attenuationR * densityToSampleAccum.x + attenuationM * densityToSampleAccum.y) );
  return lightRadiance * attenuationToSample;
}
    
    ]]>
  </shader>

  <technique name="ComputeSunRadiance">
    <pass>
      <state value="disableDepth"/>
      <vs entry="PostProcessVS"/>
      <ps entry="ComputeSunRadiancePS"/>
    </pass>
  </technique>
  
</effect>