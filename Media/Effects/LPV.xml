<?xml version="1.0" encoding="utf-8"?>

<effect>
  <include name="CommonState.xml"/>
  <include name="LPVCommon.xml"/>
  <include name="Lighting.xml"/>

  <variable type="Texture2D" name="rsmDepth"/>
  <variable type="Texture2D" name="rsmNormal"/>
  <variable type="Texture2D" name="rsmDiffuseColor"/>

  <variable type="RWStructuredBuffer" format="VPL" name="vplListBufferRW"/>
  <variable type="RWByteAddressBuffer" name="vplHeadBufferRW"/>
  <variable type="StructuredBuffer" format="VPL" name="vplListBuffer"/>
  <variable type="ByteAddressBuffer" name="vplHeadBuffer"/>

  <variable type="cbuffer" name="cb_rsm">
    <variable type="float4x4" name="rsmCropToWorld"/>
  </variable>

  <variable type="cbuffer" name="cb_rsmSize">
    <variable type="float4" name="rsmTexSize"/>
  </variable>

  <shader>
    <![CDATA[
    
[numthreads(64,1,1)]
void ClearVPLsCS(uint3 DTid : SV_DispatchThreadID)
{
    vplHeadBufferRW.Store(DTid.x * 4, -1);
}
    
    ]]>
  </shader>

  <technique name="ClearVPLs">
    <pass>
      <cs entry="ClearVPLsCS"/>
    </pass>
  </technique>
  
  <shader>
    <![CDATA[
    
[numthreads(8,8,1)]
void GenerateVPLsCS(uint3 DTid : SV_DispatchThreadID)
{
    if( float(DTid.x) >= rsmTexSize.x || float(DTid.y) >= rsmTexSize.y )
        return;
        
    float depth = rsmDepth.Load( int3(DTid.xy, 0) ).x;
    float3 normal = rsmNormal.Load( int3(DTid.xy, 0) ).xyz;
    float3 flux = rsmDiffuseColor.Load( int3(DTid.xy, 0) ).xyz;
    
    normal = normal * 2.0f - 1.0f;
    
    float2 texCoord = float2(DTid.xy) * rsmTexSize.zw;
    float3 cropPos = float3(texCoord * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f), depth);
    float3 worldPos = mul(float4(cropPos, 1.0f), rsmCropToWorld).xyz;
    
    worldPos += normal * 0.5f;
    
    //Add VPL
    VPL newVPL;
    newVPL.normal = normal;
    newVPL.flux = flux / 32.0f;
    int gridIndex = GetGridIndex(worldPos);
    if(gridIndex != -1)
    {
        int newHead = vplListBufferRW.IncrementCounter();
        int preHead;
        vplHeadBufferRW.InterlockedExchange(gridIndex * 4, newHead, preHead);
        
        newVPL.next = preHead;
        
        vplListBufferRW[newHead] = newVPL;
    }
}
    
    ]]>
  </shader>

  <technique name="GenerateVPLs">
    <pass>
      <cs entry="GenerateVPLsCS"/>
    </pass>
  </technique>

  
  <shader>
    <![CDATA[
    
[numthreads(4, 4, 4)]
void GVInjectCS(uint3 DTid : SV_DispatchThreadID)
{
    int gridIndex = GridPosToIndex( float3(DTid) );
    
    GVCell gvCell;
    [unroll] for(int i = 0; i < 9; ++i)
        gvCell.coeffs[i] = 0.0f;
    
    int vplIndex = vplHeadBuffer.Load(gridIndex * 4);
    while(vplIndex != -1)
    {
        VPL vpl = vplListBuffer[vplIndex];
        
        float weight = dot(-lightDir, vpl.normal);
        weight = max(weight, 0.25);
        weight = 1.0f / weight;
        
        AccumSH(-vpl.normal, weight, gvCell);
        
        vplIndex = vpl.next;
    }
    
    WriteGVCell( int3(DTid), gvCell);
}
    
    ]]>
  </shader>

  <technique name="GVInject">
    <pass>
      <cs entry="GVInjectCS"/>
    </pass>
  </technique>

  <shader>
    <![CDATA[
    
[numthreads(4, 4, 4)]
void LPVInjectCS(uint3 DTid : SV_DispatchThreadID)
{
    int gridIndex = GridPosToIndex( float3(DTid) );
    
    LPVCell lpvCell;
    [unroll] for(int i = 0; i < 9; ++i)
        lpvCell.coeffs[i] = 0.0f;
    
    int vplIndex = vplHeadBuffer.Load(gridIndex * 4);
    while(vplIndex != -1)
    {
        VPL vpl = vplListBuffer[vplIndex];
        float solidAngle = 3.14;
        
        float weight = dot(-lightDir, vpl.normal);
        weight = max(weight, 0.25);
        weight = 1.0f / weight;
        
        AccumSH(vpl.normal, vpl.flux * weight, solidAngle, lpvCell);
        
        vplIndex = vpl.next;
    }
    
    WriteLPVCell( int3(DTid), lpvCell);
}
    
    ]]>
  </shader>

  <technique name="LPVInject">
    <pass>
      <cs entry="LPVInjectCS"/>
    </pass>
  </technique>


  <shader>
    <![CDATA[
 
#define L1 1.0f
#define L2 0.7071067f
#define L3 0.5773502f

#define PROPAGATE_NUM_SAMPLES 26
#define PROPAGATE_WEIGHT 0.1
#define OCCLUSION_SCALE 1.0

void GetGVWeights(
    int3 gridPos,
    float3 nDirs[PROPAGATE_NUM_SAMPLES],
    out float weights[PROPAGATE_NUM_SAMPLES])
{
    GVCell gvCells[8];
	  gvCells[0] = ReadGVCell( gridPos );
	  gvCells[1] = ReadGVCell( gridPos + int3(1, 0, 0) );
	  gvCells[2] = ReadGVCell( gridPos + int3(0, 1, 0) );
	  gvCells[3] = ReadGVCell( gridPos + int3(1, 1, 0) );
	  gvCells[4] = ReadGVCell( gridPos + int3(0, 0, 1) );
	  gvCells[5] = ReadGVCell( gridPos + int3(1, 0, 1) );
	  gvCells[6] = ReadGVCell( gridPos + int3(0, 1, 1) );
	  gvCells[7] = ReadGVCell( gridPos + int3(1, 1, 1) );
    
	  [unroll] for ( int i=0; i<26; i++ ) weights[i] = 1.0f;
    
    // 8 1-tap weights (corners)
	  {
		    const int destIndex[8] = { 0, 17, 6, 23, 2, 19, 8, 25 };
		    for ( int i = 0; i < 8; ++i )
		    {
			      const float3 direction = -nDirs[ destIndex[i] ];
			      weights[ destIndex[i] ] = 1.0f - saturate( SynSHCoeffs9( direction, gvCells[i].coeffs ) ) * OCCLUSION_SCALE;
		    }
	  }
    
	  // 12 2-tap weights (edges)
	  {
		    const int destIndex[12]      = {  1,	 3,	    5,	   7,	  9,	 11,	14,    16,    18,    20,    22,    24 };
		    const int sourceIndex[12][2] = { {0,4}, {0,2}, {4,6}, {2,6}, {0,1}, {4,5}, {2,3}, {6,7}, {1,5}, {1,3}, {5,7}, {3,7} };
		    for ( int i = 0; i < 12; ++i )
		    {
			      const float3 direction = -nDirs[ destIndex[i] ];
			      float cellWeight = SynSHCoeffs9( direction, gvCells[ sourceIndex[i][0] ].coeffs ) * OCCLUSION_SCALE;
			      cellWeight		+= SynSHCoeffs9( direction, gvCells[ sourceIndex[i][1] ].coeffs ) * OCCLUSION_SCALE;
			      weights[ destIndex[i] ] = 1.0f - saturate( cellWeight * 0.5f );
		    }
	  }
    
	  // 6 4-tap weights (faces)
	  {
		    const int destIndex[6]      = {  4,         10,        12,        13,        15,        21 };
		    const int sourceIndex[6][4] = { {0,2,4,6}, {0,1,4,5}, {0,1,2,3}, {4,5,6,7}, {2,3,6,7}, {1,3,5,7} };
		    for ( int i = 0; i < 6; ++i )
		    {
			      const float3 direction = -nDirs[ destIndex[i] ];
			      float cellWeight = SynSHCoeffs9( direction, gvCells[ sourceIndex[i][0] ].coeffs ) * OCCLUSION_SCALE;
			      cellWeight		+= SynSHCoeffs9( direction, gvCells[ sourceIndex[i][1] ].coeffs ) * OCCLUSION_SCALE;
			      cellWeight		+= SynSHCoeffs9( direction, gvCells[ sourceIndex[i][2] ].coeffs ) * OCCLUSION_SCALE;
			      cellWeight		+= SynSHCoeffs9( direction, gvCells[ sourceIndex[i][3] ].coeffs ) * OCCLUSION_SCALE;
			      weights[ destIndex[i] ] = 1.0f - saturate( cellWeight * 0.25f );
		    }
	  }
}
 
[numthreads(4, 4, 4)]
void LPVPropagateCS(uint3 DTid : SV_DispatchThreadID)
{
    LPVCell cell = ReadLPVCell( int3(DTid) );
    
#if PROPAGATE_NUM_SAMPLES == 26
    const int3 sampleDirs[PROPAGATE_NUM_SAMPLES] = 
    {
        int3(-1,-1,-1 ), int3(-1,-1, 0 ), int3(-1,-1, 1 ), int3(-1, 0,-1 ), int3(-1, 0, 0 ), int3(-1, 0, 1 ), int3(-1, 1,-1 ), int3(-1, 1, 0 ), int3(-1, 1, 1 ),
			  int3( 0,-1,-1 ), int3( 0,-1, 0 ), int3( 0,-1, 1 ), int3( 0, 0,-1 ),                  int3( 0, 0, 1 ), int3( 0, 1,-1 ), int3( 0, 1, 0 ), int3( 0, 1, 1 ),
			  int3( 1,-1,-1 ), int3( 1,-1, 0 ), int3( 1,-1, 1 ), int3( 1, 0,-1 ), int3( 1, 0, 0 ), int3( 1, 0, 1 ), int3( 1, 1,-1 ), int3( 1, 1, 0 ), int3( 1, 1, 1 )
    };
    
    const float3 nSampleDirs[PROPAGATE_NUM_SAMPLES] = 
    {
        float3(-L3,-L3,-L3 ), float3(-L2,-L2, 0  ), float3(-L3,-L3, L3 ), float3(-L2, 0 ,-L2 ), float3(-L1, 0 , 0  ), float3(-L2, 0 , L2 ), float3(-L3, L3,-L3 ), float3(-L2, L2, 0  ), float3(-L3, L3, L3 ),
			  float3( 0 ,-L2,-L2 ), float3( 0 ,-L1, 0  ), float3( 0 ,-L2, L2 ), float3( 0 , 0 ,-L1 ),						            float3( 0 , 0 , L1 ), float3( 0 , L2,-L2 ), float3( 0 , L1, 0  ), float3( 0 , L2, L2 ),
			  float3( L3,-L3,-L3 ), float3( L2,-L2, 0  ), float3( L3,-L3, L3 ), float3( L2, 0 ,-L2 ), float3( L1, 0 , 0  ), float3( L2, 0 , L2 ), float3( L3, L3,-L3 ), float3( L2, L2, 0  ), float3( L3, L3, L3 )
    };
#endif

#ifdef GEOMETRY_OCCLUSION
    float gvWeights[PROPAGATE_NUM_SAMPLES];
    GetGVWeights( int3(DTid), nSampleDirs, gvWeights);
#endif

    [loop] for(int i = 0; i < PROPAGATE_NUM_SAMPLES; ++i)
    {
        int3 sampleGridPos = int3(DTid) + sampleDirs[i];
        
        LPVCell sampleCell = ReadLPVCell(sampleGridPos);
        
        float3 nDir = float3(sampleDirs[i]);
        float len2 = dot(nDir, nDir);
        nDir = nSampleDirs[i];
        
        float weight = 1.0f / len2 * PROPAGATE_WEIGHT;
        
#ifdef GEOMETRY_OCCLUSION
        weight *= gvWeights[i];
#endif
        
        float3 sampleColor = SynSHCoeffs9(-nDir, sampleCell.coeffs);
        
        sampleColor *= weight;
        
        AccumSH(-nDir, sampleColor, 1.0f, cell);
    }
    
    WriteLPVCell(int3(DTid), cell);
}
    
    ]]>
  </shader>

  <technique name="LPVPropagate">
    <pass>
      <cs entry="LPVPropagateCS"/>
    </pass>
  </technique>
  
</effect>
