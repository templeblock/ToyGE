#include "Common.tshader"
#include "DrawQuad.tshader"

float4 texSize;
SamplerState pointBorderSampler;
SamplerState pointSampler;
SamplerState linearSampler;

Texture2D sceneDownSampleTex;
Texture2D illumReduceTex;
Texture2D prevAvgAdaptedIlumTex;
Texture2D avgAdaptedIlumTex;

float ComputeIlluminaceInitialPS(DrawQuadVSOut vsOut) : SV_TARGET
{
    float2 texelSize = texSize.zw;
    float2 texelCenterCoord = (vsOut.pos.xy - 0.5f) * 3.0f + 1.5f;
    float2 texCenter = vsOut.uv;
  
    float sum = 0.0f;
    int numSamples = 0;
    [unroll] for(int y = -1; y <= 1; ++y)
    {
        [unroll] for(int x = -1; x <= 1; ++x)
        {
            float2 texSample = texelSize * (texelCenterCoord + float2(x, y));
            if(texSample.x <= 1.0f && texSample.y <= 1.0f)
            {
                float3 color = sceneDownSampleTex.SampleLevel(pointBorderSampler, texSample, 0).xyz;
                float ilum = GetIlluminance(color);
                sum += log(0.001f + ilum);
                ++numSamples;
            }
        }
    }
  
    if(numSamples >= 1)
        sum /= numSamples;
        
    return sum;
}

float ComputeIlluminaceReducePS(DrawQuadVSOut vsOut) : SV_TARGET
{
    float2 texelCoordLU = (vsOut.pos.xy - 0.5f) * 4.0f + 0.5f;
    float2 texelSize = texSize.zw;
  
    float2 texLU = texelCoordLU * texelSize;
    float sum = 0.0f;
    [unroll] for(int y = 0; y < 4; ++y)
    {
        [unroll] for(int x = 0; x < 4; ++x)
        {
            float2 sam = illumReduceTex.SampleLevel(pointBorderSampler, texLU + texelSize * float2(x, y), 0).xy;
            sum += sam.x;
        }
    }
  
    return sum / 16.0f;
}

float elapsedTime;

float2 ComputeAvgAndAdaptedIlumPS(DrawQuadVSOut vsOut) : SV_TARGET
{
  float logAvgIlum = illumReduceTex.SampleLevel(pointSampler, float2(0.5, 0.5) / 64.0, 0).x;
  float avgIlum = exp(logAvgIlum);
  float prevAdaptedIlum = prevAvgAdaptedIlumTex.SampleLevel(pointSampler, vsOut.uv, 0).y;
  float adaptedIlum = lerp(prevAdaptedIlum, avgIlum, 1.0 - pow(0.98, 100.0 * elapsedTime));
  
  return float2(avgIlum, adaptedIlum);
}


cbuffer cb_brightPass
{
    float brightPassThreshold;
    float brightPassScale;
};

float3 BrightPassPS(DrawQuadVSOut vsOut) : SV_TARGET
{
  float adaptedIllum = avgAdaptedIlumTex.SampleLevel(pointSampler, float2(0.5, 0.5), 0).y;
  
  float3 color = sceneDownSampleTex.SampleLevel(pointSampler, vsOut.uv, 0).xyz;
  float key = max(0.0f, 1.5f - 1.5f / (adaptedIllum * 0.1f + 1.0f)) + 0.1f;
  float illumScaled = key * GetIlluminance(color) / (adaptedIllum + 0.001f);
  float lBright = max(0, illumScaled - brightPassThreshold);
  float brightScale = lBright / (brightPassScale + lBright);
  
  return color * brightScale;
}



float3 Uncharted2Tonemap(float3 x)
{
    static float A = 0.15;
    static float B = 0.50;
    static float C = 0.10;
    static float D = 0.20;
    static float E = 0.02;
    static float F = 0.30;
    static float W = 11.2;
  
    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F; 
}

float3 BlueShift(float3 color)
{
    const float3 BLUE_SHIFT = float3(0.4f, 0.4f, 0.7f);
    float ilum = GetIlluminance(color);
  
    //martin's modified blue shift
    return lerp(ilum * BLUE_SHIFT, color, saturate(16.0f * ilum));
}

float3 ToneMapping(float3 color, float adaptedIllum)
{  
	color = BlueShift(color);

    static float W = 11.2;
    float exposure = 3 / (max(0.1f, 1 + 10 * lerp(0.2, adaptedIllum, 0.5)));
    return Uncharted2Tonemap(color * 1.60f * exposure) / Uncharted2Tonemap(W);
}


Texture2D sceneTex;
Texture2D blurTex;
Texture2D streakTex;

float3 HDRCombinePS(DrawQuadVSOut vsOut) : SV_TARGET
{
    float3 sceneColor = sceneTex.SampleLevel(pointSampler, vsOut.uv, 0).xyz;
    float3 blurColor = blurTex.SampleLevel(linearSampler, vsOut.uv, 0).xyz; 
    float3 streakColor = streakTex.SampleLevel(linearSampler, vsOut.uv, 0).xyz;
  
    float3 mergeColor = sceneColor + 0.15f * blurColor + 0.1f * streakColor;
  
    float adaptedIllum = avgAdaptedIlumTex.SampleLevel(pointSampler, float2(0.5, 0.5), 0).y;
    float3 ldrColor = ToneMapping(mergeColor, adaptedIllum);
  
    return ldrColor;
}