#include "Common.tshader"
#include "DrawQuad.tshader"
#include "Material.tshader"
#include "GBuffer.tshader"
#include "View.tshader"
#include "BRDF.tshader"
#include "ScreenSpaceTracing.tshader"

Texture2D sceneTex;
Texture2D depthTex;
Texture2D gbuffer0;
Texture2D gbuffer1;

SamplerState pointSampler;
SamplerState pointClampSampler;
SamplerState linearSampler;

float4 screenSize;
int frameCount;
float ssrMaxRoughness;
float ssrIntensity;
float mipLevel;

float HZBBuildPS(DrawQuadVSOut vsOut) : SV_TARGET
{
    float2 uv0 = vsOut.uv + float2(-0.5f, -0.5f) * screenSize.zw;
    float2 uv1 = vsOut.uv + float2( 0.5f, -0.5f) * screenSize.zw;
    float2 uv2 = vsOut.uv + float2(-0.5f,  0.5f) * screenSize.zw;
    float2 uv3 = vsOut.uv + float2( 0.5f,  0.5f) * screenSize.zw;
  
    float z0 = depthTex.SampleLevel(pointSampler, uv0, mipLevel).x;
    float z1 = depthTex.SampleLevel(pointSampler, uv1, mipLevel).x;
    float z2 = depthTex.SampleLevel(pointSampler, uv2, mipLevel).x;
    float z3 = depthTex.SampleLevel(pointSampler, uv3, mipLevel).x;
  
    return min( min(z0, z1), min(z2, z3) );
}


#define NUM_RAYS 4
#define NUM_SAMPLES_PER_RAY 4
    
uint MortonCode( uint x )
{
	//x = (x ^ (x <<  8)) & 0x00ff00ff;
	//x = (x ^ (x <<  4)) & 0x0f0f0f0f;
	x = (x ^ (x <<  2)) & 0x33333333;
	x = (x ^ (x <<  1)) & 0x55555555;
	return x;
}

uint ReverseUIntBits( uint bits )
{
	//bits = ( bits << 16) | ( bits >> 16);
	//bits = ( (bits & 0x00ff00ff) << 8 ) | ( (bits & 0xff00ff00) >> 8 );
	//bits = ( (bits & 0x0f0f0f0f) << 4 ) | ( (bits & 0xf0f0f0f0) >> 4 );
	bits = ( (bits & 0x33333333) << 2 ) | ( (bits & 0xcccccccc) >> 2 );
	bits = ( (bits & 0x55555555) << 1 ) | ( (bits & 0xaaaaaaaa) >> 1 );
	return bits;
}

float4 SampleTexDepth(float4 sampleUV0, float4 sampleUV1, float level)
{
    float z0 = depthTex.SampleLevel(pointClampSampler, sampleUV0.xy, level).x;
    float z1 = depthTex.SampleLevel(pointClampSampler, sampleUV0.zw, level).x;
    float z2 = depthTex.SampleLevel(pointClampSampler, sampleUV1.xy, level).x;
    float z3 = depthTex.SampleLevel(pointClampSampler, sampleUV1.zw, level).x;
    
    return float4(z0, z1, z2, z3);
}



float3 RandomTraceDir(float3 view, float3 normal, float roughness, float2 screenPos, uint rayIndex, uint2 random)
{
    float3 traceDir;

    {    
        float2 sample2D = Hammersley2d(rayIndex, NUM_RAYS, random);
        
        float e0 = sample2D.x;
        float e1 = sample2D.y;
        
        e0 += 0.001f;
        e1 += 0.001f;
        
        float3 zAxis = abs(normal.z) < 0.99 ? float3(0.0f, 0.0f, 1.0f) : float3(1.0f, 0.0f, 0.0f);
        float3 yAxis = normal;
        float3 xAxis = normalize( cross(yAxis, zAxis) );
        zAxis = cross(xAxis, yAxis);
        
        float a = roughness * roughness;
        float a2 = a * a;
        
        //Blinn
        float n = 2 / a2 - 2;
        float phi = 2 * PI * e0;
        float cosTheta = pow( e1, 1 / (n + 1) );
        float sinTheta = sqrt( 1 - cosTheta * cosTheta );
        
        float3 h = yAxis * cosTheta + xAxis * sinTheta * sin(phi) + zAxis * sinTheta * cos(phi);
        
        traceDir = reflect(-view, h);
    }
    
    return traceDir;
}


// float4 RayTracing(
//     float3 startPosView, 
//     float3 traceDirView, 
//     float roughness, 
//     int numSamples, 
//     float3 rayStartClip, 
//     float3 rayStartUVZ, 
//     float offset)
// {
//     float3 rayStartView = startPosView;
//     float3 rayEndView = startPosView + traceDirView;
//     
//     float4 rayEndClip = mul(float4(rayEndView, 1.0f), viewToClipMatrix);
//     rayEndClip.xyz /= rayEndClip.w;
//     
//     float rayStepUVBorderScale = 1.5 / length(rayEndClip.xy - rayStartClip.xy);
//     float rayStepZBorderScale  = (0.5 * (sign(traceDirView.z) + 1) - rayStartClip.z) / (rayEndClip.z - rayStartClip.z);
//     float rayStepScale = min(rayStepUVBorderScale, rayStepZBorderScale);
//     float3 rayStepClip = (rayEndClip.xyz - rayStartClip) * rayStepScale;
//     rayStepClip /= float(numSamples + 1);
//     
//     float3 rayStepUVZ = float3(rayStepClip.xy * float2(0.5, -0.5), rayStepClip.z);
//     
//     const float depthTolerance = abs( rayStepUVZ.z ) * 1.0;
//     
//     float lastDepthDiff = abs(rayStepUVZ.z);
//     float3 hitUVz = 0.0f;
//     float hitPos = 0.0f;
//     
//     float4 samplePos = float4(1, 2, 3, 4) + offset;
//     float level = 0.0f;
//     
//     [unroll] for(int i = 0; i < numSamples; i += 4)
//     {
//         float4 sampleUV0 = rayStartUVZ.xyxy + samplePos.xxyy * rayStepUVZ.xyxy;
//         float4 sampleUV1 = rayStartUVZ.xyxy + samplePos.zzww * rayStepUVZ.xyxy;
//         float4 sampleRayDepth = ( rayStartUVZ.z + samplePos * rayStepUVZ.z );
//         
//         float4 sampleTexDepth = SampleTexDepth(sampleUV0, sampleUV1, level);
//         
//         float4 depthDiffCur = sampleRayDepth - sampleTexDepth;
//         //bool4 hit = abs(-depthDiffCur - depthTolerance) < depthTolerance;
//         bool4 hit = abs(depthDiffCur - depthTolerance) < depthTolerance;
//         //bool4 hit = depthDiffCur > 0.0f;
//         
//         [branch] if( any(hit) )
//         {
//             float4 depthDiffPre = float4(lastDepthDiff, depthDiffCur.xyz);
//             //float4 hitPos4 = samplePos + saturate( -depthDiffCur / (depthDiffCur - depthDiffPre) );
//             //hitPos4 = hit ? hitPos4 : -FLT_MAX;
//             
//             //hitPos = max( max(hitPos4.x, hitPos4.y), max(hitPos4.z, hitPos4.w) );
//             
//             float4 hitPos4 = samplePos - saturate( depthDiffCur / (depthDiffCur - depthDiffPre) );
//             hitPos4 = hit ? hitPos4 : FLT_MAX;
//             
//             hitPos = min( min(hitPos4.x, hitPos4.y), min(hitPos4.z, hitPos4.w) );
//             
//             //bHit = true;
//             hitUVz = rayStartUVZ + hitPos * rayStepUVZ;
//             
//             break;
//         }
//         
//         lastDepthDiff = depthDiffCur.w;
//         
//         samplePos += 4;
//         //level += 9 * roughness / numSamples;
//     }
//     
//     return float4(hitUVz, hitPos / (numSamples + 1));
// }

float3 SampleSceneColor(float4 hitResult)
{
    float3 traceColor = 0.0f;
    {
        traceColor = sceneTex.SampleLevel(linearSampler, hitResult.xy, 0).rgb;
        
        float2 hitCenterDist = abs( hitResult.xy - 0.5 ) * 2.0;
        hitCenterDist = saturate( hitCenterDist * 5.0 - 4.0 );
        float borderFade = saturate( 1.0 - dot(hitCenterDist, hitCenterDist) );
        
        traceColor *= borderFade;
        
        traceColor *= saturate( 4 - hitResult.w * 4 );
    }
    
    return traceColor;
}

float3 ScreenSpaceReflectionPS(DrawQuadVSOut vsOut) : SV_TARGET
{
    GBuffer gbuf;
    
    gbuf.gbuf0 = gbuffer0.SampleLevel(pointClampSampler, vsOut.uv, 0.0f);
    gbuf.gbuf1 = gbuffer1.SampleLevel(pointClampSampler, vsOut.uv, 0.0f);
    
    Material mat = GBufferToMaterial(gbuf);
    
    float roughnessFade = 1.0 - saturate( mat.roughness / max(1e-4, ssrMaxRoughness) );
    [branch] if(roughnessFade <= 1e-4)
        return 0;
  
    float  originClipDepth = depthTex.SampleLevel(pointClampSampler, vsOut.uv, 0).x;
    float2 originClipPosXY = GetClipPosXYFromScreen(vsOut.pos.xy, viewSize.xy);
    float3 originViewPos = GetViewPosFromPespective(float3(originClipPosXY, originClipDepth), viewToClipMatrix);
    
    float roughness = lerp(0.1, 0.9, mat.roughness);
    
    float3 originWorldNormal = mat.normal;
    float3 originViewNormal  = mul(originWorldNormal, (float3x3)worldToViewMatrix);
    
    float3 viewDir = normalize(-originViewPos);
    
    uint frameRandom = ((uint)frameCount % 4) * 1551;
    
    float3 traceColor = 0.0f;
    
    float3 rayClipStart  = float3(originClipPosXY, originClipDepth);
    float3 rayUVZStart   = float3(vsOut.uv, originClipDepth);
    
    float3 traceMainViewDir = reflect(-viewDir, originViewNormal);
    
#if NUM_RAYS > 1
    
    uint morton = MortonCode( uint(vsOut.pos.x) & 3 ) | ( MortonCode( uint(vsOut.pos.y) & 3 ) * 2 );
    uint pixelIndex = ReverseUIntBits( morton );    
    uint2 random = ScrambleTEA( uint2( vsOut.pos.xy ), 3 );
    
    [unroll] for(int i = 0; i < NUM_RAYS; ++i)
    {
        uint offset = ( pixelIndex + ReverseUIntBits( uint(i) * 117 ) ) & 15;
        float stepOffset = offset / 15.0;
        stepOffset -= 0.9;
    
        float3 traceViewDir = RandomTraceDir(viewDir, originViewNormal, roughness, vsOut.pos.xy, uint(i), random);
        
        if(traceViewDir.z < -0.99)
            continue;
        
        float3 traceViewEnd = originViewPos + traceViewDir;
        float4 traceClipEnd = mul(float4(traceViewEnd, 1.0), viewToClipMatrix);
        traceClipEnd /= traceClipEnd.w;
        float3 traceUVZEnd = float3(traceClipEnd.xy * float2(0.5, -0.5) + float2(0.5, 0.5), traceClipEnd.z);
        
        float3 traceUVZDir = traceUVZEnd - rayUVZStart;
        
        // float4 traceResult = RayTracing(
        //     originViewPos, 
        //     traceViewDir, 
        //     roughnessFade, 
        //     NUM_SAMPLES_PER_RAY, 
        //     rayClipStart, 
        //     rayUVZStart, 
        //     stepOffset);
        
        float4 traceResult = RayTracing(
            depthTex,
            pointClampSampler,
            rayUVZStart,
            traceUVZDir,
            // roughnessFade, 
            NUM_SAMPLES_PER_RAY, 
            stepOffset
        );
        
        [branch] if(traceResult.w != 0.0)
        {
            float3 traceColorRay = SampleSceneColor(traceResult);
            traceColorRay /= 1 + max(max(traceColorRay.x, traceColorRay.y), traceColorRay.z);
        
            traceColor += traceColorRay;
        }       
    }
    traceColor /= float(NUM_RAYS);
    //traceColor /= 1 + GetIlluminance(traceColor) * 2.0;
    // traceColor /= max(1e-5, 1 - GetIlluminance(traceColor));
    
#else
    
    {
        float3 traceViewDir = traceMainViewDir;
        if(tranceDirV.z < -0.99)
        {
            traceColor = 0.0f
        }
        else
        {
            // float4 traceResult = RayTracing(
            //     originViewPos, 
            //     traceViewDir, 
            //     roughness, 
            //     roughnessFade, 
            //     NUM_SAMPLES_PER_RAY, 
            //     rayClipStart, 
            //     rayUVZStart, 
            //     uint(i) * 117);
            
            float3 traceViewEnd = originViewPos + traceViewDir;
            float4 traceClipEnd = mul(float4(traceViewEnd, 1.0), viewToClipMatrix);
            traceClipEnd /= traceClipEnd.w;
            float3 traceUVZEnd = float3(traceClipEnd.xy * float2(0.5, -0.5) + float2(0.5, 0.5), traceClipEnd.z);
            
            float3 traceUVZDir = traceUVZEnd - rayUVZStart;
            
            float4 traceResult = RayTracing(
                depthTex,
                pointClampSampler,
                rayUVZStart,
                traceUVZDir,
                // roughnessFade, 
                NUM_SAMPLES_PER_RAY, 
                stepOffset
            );
        
            [branch] if(traceResult.w != 0.0)
            {
                traceColor += SampleSceneColor(traceResult);
            }
        }
    }
    
#endif
    
    traceColor *= roughnessFade;
    
    float3 n = originViewNormal;
    float3 l = traceMainViewDir;
    float3 v = viewDir;
    float3 h = normalize(v + l);
    
    //float3 reflectColor = traceColor * (F + diffColor / PI) * max(0.0f, ssrIntensity);
    traceColor /= PI;
    
    float3 spec = Fresnel(max(1e-3, dot(v, h)), mat.specularColor);
    
    float3 reflectColor = traceColor * ( mat.diffuseColor / PI + spec );
    //float3 reflectColor = traceColor * ( mat.diffuseColor / PI );
    reflectColor *= ssrIntensity;
    
    return reflectColor;
}